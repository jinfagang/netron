// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TYPE_WNN_H_
#define FLATBUFFERS_GENERATED_TYPE_WNN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

namespace wnn {

struct Quant;
struct QuantBuilder;
struct QuantT;

inline const flatbuffers::TypeTable *QuantTypeTable();

enum DataType : int32_t {
  DataType_DT_INVALID = 0,
  DataType_DT_FLOAT = 1,
  DataType_DT_DOUBLE = 2,
  DataType_DT_INT32 = 3,
  DataType_DT_UINT8 = 4,
  DataType_DT_INT16 = 5,
  DataType_DT_INT8 = 6,
  DataType_DT_STRING = 7,
  DataType_DT_COMPLEX64 = 8,
  DataType_DT_INT64 = 9,
  DataType_DT_BOOL = 10,
  DataType_DT_QINT8 = 11,
  DataType_DT_QUINT8 = 12,
  DataType_DT_QINT32 = 13,
  DataType_DT_BFLOAT16 = 14,
  DataType_DT_QINT16 = 15,
  DataType_DT_QUINT16 = 16,
  DataType_DT_UINT16 = 17,
  DataType_DT_COMPLEX128 = 18,
  DataType_DT_FLOAT16 = 19,
  DataType_DT_TFLOAT32 = 20,
  DataType_MIN = DataType_DT_INVALID,
  DataType_MAX = DataType_DT_TFLOAT32
};

inline const DataType (&EnumValuesDataType())[21] {
  static const DataType values[] = {
    DataType_DT_INVALID,
    DataType_DT_FLOAT,
    DataType_DT_DOUBLE,
    DataType_DT_INT32,
    DataType_DT_UINT8,
    DataType_DT_INT16,
    DataType_DT_INT8,
    DataType_DT_STRING,
    DataType_DT_COMPLEX64,
    DataType_DT_INT64,
    DataType_DT_BOOL,
    DataType_DT_QINT8,
    DataType_DT_QUINT8,
    DataType_DT_QINT32,
    DataType_DT_BFLOAT16,
    DataType_DT_QINT16,
    DataType_DT_QUINT16,
    DataType_DT_UINT16,
    DataType_DT_COMPLEX128,
    DataType_DT_FLOAT16,
    DataType_DT_TFLOAT32
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[22] = {
    "DT_INVALID",
    "DT_FLOAT",
    "DT_DOUBLE",
    "DT_INT32",
    "DT_UINT8",
    "DT_INT16",
    "DT_INT8",
    "DT_STRING",
    "DT_COMPLEX64",
    "DT_INT64",
    "DT_BOOL",
    "DT_QINT8",
    "DT_QUINT8",
    "DT_QINT32",
    "DT_BFLOAT16",
    "DT_QINT16",
    "DT_QUINT16",
    "DT_UINT16",
    "DT_COMPLEX128",
    "DT_FLOAT16",
    "DT_TFLOAT32",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (flatbuffers::IsOutRange(e, DataType_DT_INVALID, DataType_DT_TFLOAT32)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum DeviceType : int32_t {
  DeviceType_kX86 = 0,
  DeviceType_kARM = 1,
  DeviceType_kOPENCL = 2,
  DeviceType_kMETAL = 3,
  DeviceType_kCUDA = 4,
  DeviceType_kDSP = 5,
  DeviceType_kATLAS = 6,
  DeviceType_kHUAWEI_NPU = 7,
  DeviceType_kRK_NPU = 8,
  DeviceType_kAPPLE_NPU = 9,
  DeviceType_kCPU = 10,
  DeviceType_MIN = DeviceType_kX86,
  DeviceType_MAX = DeviceType_kCPU
};

inline const DeviceType (&EnumValuesDeviceType())[11] {
  static const DeviceType values[] = {
    DeviceType_kX86,
    DeviceType_kARM,
    DeviceType_kOPENCL,
    DeviceType_kMETAL,
    DeviceType_kCUDA,
    DeviceType_kDSP,
    DeviceType_kATLAS,
    DeviceType_kHUAWEI_NPU,
    DeviceType_kRK_NPU,
    DeviceType_kAPPLE_NPU,
    DeviceType_kCPU
  };
  return values;
}

inline const char * const *EnumNamesDeviceType() {
  static const char * const names[12] = {
    "kX86",
    "kARM",
    "kOPENCL",
    "kMETAL",
    "kCUDA",
    "kDSP",
    "kATLAS",
    "kHUAWEI_NPU",
    "kRK_NPU",
    "kAPPLE_NPU",
    "kCPU",
    nullptr
  };
  return names;
}

inline const char *EnumNameDeviceType(DeviceType e) {
  if (flatbuffers::IsOutRange(e, DeviceType_kX86, DeviceType_kCPU)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDeviceType()[index];
}

enum QuantType : int8_t {
  QuantType_no_quant = 0,
  QuantType_int8 = 1,
  QuantType_sparse_quant = 2,
  QuantType_fp16 = 3,
  QuantType_bfp16 = 4,
  QuantType_weight_int8 = 5,
  QuantType_int4 = 6,
  QuantType_MIN = QuantType_no_quant,
  QuantType_MAX = QuantType_int4
};

inline const QuantType (&EnumValuesQuantType())[7] {
  static const QuantType values[] = {
    QuantType_no_quant,
    QuantType_int8,
    QuantType_sparse_quant,
    QuantType_fp16,
    QuantType_bfp16,
    QuantType_weight_int8,
    QuantType_int4
  };
  return values;
}

inline const char * const *EnumNamesQuantType() {
  static const char * const names[8] = {
    "no_quant",
    "int8",
    "sparse_quant",
    "fp16",
    "bfp16",
    "weight_int8",
    "int4",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantType(QuantType e) {
  if (flatbuffers::IsOutRange(e, QuantType_no_quant, QuantType_int4)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantType()[index];
}

struct QuantT : public flatbuffers::NativeTable {
  typedef Quant TableType;
  std::vector<int8_t> buffer{};
  std::vector<float> alpha{};
  wnn::QuantType quant_type = wnn::QuantType_no_quant;
  bool use_int32 = false;
  float quant_scale = 0.0f;
  float scale_in = 0.0f;
  float scale_out = 0.0f;
  int32_t a_max = 0;
  int32_t a_min = 0;
  int32_t read_type = 0;
  bool has_scale_int = false;
};

struct Quant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef QuantT NativeTableType;
  typedef QuantBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return QuantTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BUFFER = 4,
    VT_ALPHA = 6,
    VT_QUANT_TYPE = 8,
    VT_USE_INT32 = 10,
    VT_QUANT_SCALE = 12,
    VT_SCALE_IN = 14,
    VT_SCALE_OUT = 16,
    VT_A_MAX = 18,
    VT_A_MIN = 20,
    VT_READ_TYPE = 22,
    VT_HAS_SCALE_INT = 24
  };
  const flatbuffers::Vector<int8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_BUFFER);
  }
  const flatbuffers::Vector<float> *alpha() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ALPHA);
  }
  wnn::QuantType quant_type() const {
    return static_cast<wnn::QuantType>(GetField<int8_t>(VT_QUANT_TYPE, 0));
  }
  bool use_int32() const {
    return GetField<uint8_t>(VT_USE_INT32, 0) != 0;
  }
  float quant_scale() const {
    return GetField<float>(VT_QUANT_SCALE, 0.0f);
  }
  float scale_in() const {
    return GetField<float>(VT_SCALE_IN, 0.0f);
  }
  float scale_out() const {
    return GetField<float>(VT_SCALE_OUT, 0.0f);
  }
  int32_t a_max() const {
    return GetField<int32_t>(VT_A_MAX, 0);
  }
  int32_t a_min() const {
    return GetField<int32_t>(VT_A_MIN, 0);
  }
  int32_t read_type() const {
    return GetField<int32_t>(VT_READ_TYPE, 0);
  }
  bool has_scale_int() const {
    return GetField<uint8_t>(VT_HAS_SCALE_INT, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.VerifyVector(buffer()) &&
           VerifyOffset(verifier, VT_ALPHA) &&
           verifier.VerifyVector(alpha()) &&
           VerifyField<int8_t>(verifier, VT_QUANT_TYPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_USE_INT32, 1) &&
           VerifyField<float>(verifier, VT_QUANT_SCALE, 4) &&
           VerifyField<float>(verifier, VT_SCALE_IN, 4) &&
           VerifyField<float>(verifier, VT_SCALE_OUT, 4) &&
           VerifyField<int32_t>(verifier, VT_A_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_A_MIN, 4) &&
           VerifyField<int32_t>(verifier, VT_READ_TYPE, 4) &&
           VerifyField<uint8_t>(verifier, VT_HAS_SCALE_INT, 1) &&
           verifier.EndTable();
  }
  QuantT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(QuantT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Quant> Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct QuantBuilder {
  typedef Quant Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer) {
    fbb_.AddOffset(Quant::VT_BUFFER, buffer);
  }
  void add_alpha(flatbuffers::Offset<flatbuffers::Vector<float>> alpha) {
    fbb_.AddOffset(Quant::VT_ALPHA, alpha);
  }
  void add_quant_type(wnn::QuantType quant_type) {
    fbb_.AddElement<int8_t>(Quant::VT_QUANT_TYPE, static_cast<int8_t>(quant_type), 0);
  }
  void add_use_int32(bool use_int32) {
    fbb_.AddElement<uint8_t>(Quant::VT_USE_INT32, static_cast<uint8_t>(use_int32), 0);
  }
  void add_quant_scale(float quant_scale) {
    fbb_.AddElement<float>(Quant::VT_QUANT_SCALE, quant_scale, 0.0f);
  }
  void add_scale_in(float scale_in) {
    fbb_.AddElement<float>(Quant::VT_SCALE_IN, scale_in, 0.0f);
  }
  void add_scale_out(float scale_out) {
    fbb_.AddElement<float>(Quant::VT_SCALE_OUT, scale_out, 0.0f);
  }
  void add_a_max(int32_t a_max) {
    fbb_.AddElement<int32_t>(Quant::VT_A_MAX, a_max, 0);
  }
  void add_a_min(int32_t a_min) {
    fbb_.AddElement<int32_t>(Quant::VT_A_MIN, a_min, 0);
  }
  void add_read_type(int32_t read_type) {
    fbb_.AddElement<int32_t>(Quant::VT_READ_TYPE, read_type, 0);
  }
  void add_has_scale_int(bool has_scale_int) {
    fbb_.AddElement<uint8_t>(Quant::VT_HAS_SCALE_INT, static_cast<uint8_t>(has_scale_int), 0);
  }
  explicit QuantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Quant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Quant>(end);
    return o;
  }
};

inline flatbuffers::Offset<Quant> CreateQuant(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> buffer = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> alpha = 0,
    wnn::QuantType quant_type = wnn::QuantType_no_quant,
    bool use_int32 = false,
    float quant_scale = 0.0f,
    float scale_in = 0.0f,
    float scale_out = 0.0f,
    int32_t a_max = 0,
    int32_t a_min = 0,
    int32_t read_type = 0,
    bool has_scale_int = false) {
  QuantBuilder builder_(_fbb);
  builder_.add_read_type(read_type);
  builder_.add_a_min(a_min);
  builder_.add_a_max(a_max);
  builder_.add_scale_out(scale_out);
  builder_.add_scale_in(scale_in);
  builder_.add_quant_scale(quant_scale);
  builder_.add_alpha(alpha);
  builder_.add_buffer(buffer);
  builder_.add_has_scale_int(has_scale_int);
  builder_.add_use_int32(use_int32);
  builder_.add_quant_type(quant_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Quant> CreateQuantDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int8_t> *buffer = nullptr,
    const std::vector<float> *alpha = nullptr,
    wnn::QuantType quant_type = wnn::QuantType_no_quant,
    bool use_int32 = false,
    float quant_scale = 0.0f,
    float scale_in = 0.0f,
    float scale_out = 0.0f,
    int32_t a_max = 0,
    int32_t a_min = 0,
    int32_t read_type = 0,
    bool has_scale_int = false) {
  auto buffer__ = buffer ? _fbb.CreateVector<int8_t>(*buffer) : 0;
  auto alpha__ = alpha ? _fbb.CreateVector<float>(*alpha) : 0;
  return wnn::CreateQuant(
      _fbb,
      buffer__,
      alpha__,
      quant_type,
      use_int32,
      quant_scale,
      scale_in,
      scale_out,
      a_max,
      a_min,
      read_type,
      has_scale_int);
}

flatbuffers::Offset<Quant> CreateQuant(flatbuffers::FlatBufferBuilder &_fbb, const QuantT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline QuantT *Quant::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<QuantT>(new QuantT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Quant::UnPackTo(QuantT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = buffer(); if (_e) { _o->buffer.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->buffer.begin()); } }
  { auto _e = alpha(); if (_e) { _o->alpha.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->alpha[_i] = _e->Get(_i); } } }
  { auto _e = quant_type(); _o->quant_type = _e; }
  { auto _e = use_int32(); _o->use_int32 = _e; }
  { auto _e = quant_scale(); _o->quant_scale = _e; }
  { auto _e = scale_in(); _o->scale_in = _e; }
  { auto _e = scale_out(); _o->scale_out = _e; }
  { auto _e = a_max(); _o->a_max = _e; }
  { auto _e = a_min(); _o->a_min = _e; }
  { auto _e = read_type(); _o->read_type = _e; }
  { auto _e = has_scale_int(); _o->has_scale_int = _e; }
}

inline flatbuffers::Offset<Quant> Quant::Pack(flatbuffers::FlatBufferBuilder &_fbb, const QuantT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateQuant(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Quant> CreateQuant(flatbuffers::FlatBufferBuilder &_fbb, const QuantT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const QuantT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _buffer = _o->buffer.size() ? _fbb.CreateVector(_o->buffer) : 0;
  auto _alpha = _o->alpha.size() ? _fbb.CreateVector(_o->alpha) : 0;
  auto _quant_type = _o->quant_type;
  auto _use_int32 = _o->use_int32;
  auto _quant_scale = _o->quant_scale;
  auto _scale_in = _o->scale_in;
  auto _scale_out = _o->scale_out;
  auto _a_max = _o->a_max;
  auto _a_min = _o->a_min;
  auto _read_type = _o->read_type;
  auto _has_scale_int = _o->has_scale_int;
  return wnn::CreateQuant(
      _fbb,
      _buffer,
      _alpha,
      _quant_type,
      _use_int32,
      _quant_scale,
      _scale_in,
      _scale_out,
      _a_max,
      _a_min,
      _read_type,
      _has_scale_int);
}

inline const flatbuffers::TypeTable *DataTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::DataTypeTypeTable
  };
  static const char * const names[] = {
    "DT_INVALID",
    "DT_FLOAT",
    "DT_DOUBLE",
    "DT_INT32",
    "DT_UINT8",
    "DT_INT16",
    "DT_INT8",
    "DT_STRING",
    "DT_COMPLEX64",
    "DT_INT64",
    "DT_BOOL",
    "DT_QINT8",
    "DT_QUINT8",
    "DT_QINT32",
    "DT_BFLOAT16",
    "DT_QINT16",
    "DT_QUINT16",
    "DT_UINT16",
    "DT_COMPLEX128",
    "DT_FLOAT16",
    "DT_TFLOAT32"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 21, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DeviceTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::DeviceTypeTypeTable
  };
  static const char * const names[] = {
    "kX86",
    "kARM",
    "kOPENCL",
    "kMETAL",
    "kCUDA",
    "kDSP",
    "kATLAS",
    "kHUAWEI_NPU",
    "kRK_NPU",
    "kAPPLE_NPU",
    "kCPU"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantTypeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::QuantTypeTypeTable
  };
  static const char * const names[] = {
    "no_quant",
    "int8",
    "sparse_quant",
    "fp16",
    "bfp16",
    "weight_int8",
    "int4"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 7, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *QuantTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_FLOAT, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_BOOL, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::QuantTypeTypeTable
  };
  static const char * const names[] = {
    "buffer",
    "alpha",
    "quant_type",
    "use_int32",
    "quant_scale",
    "scale_in",
    "scale_out",
    "a_max",
    "a_min",
    "read_type",
    "has_scale_int"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

}  // namespace wnn

#endif  // FLATBUFFERS_GENERATED_TYPE_WNN_H_
