// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WNNX_WNN_H_
#define FLATBUFFERS_GENERATED_WNNX_WNN_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 2 &&
              FLATBUFFERS_VERSION_MINOR == 0 &&
              FLATBUFFERS_VERSION_REVISION == 6,
             "Non-compatible flatbuffers version included");

#include "custom_define_generated.h"
#include "tensor_generated.h"
#include "type_generated.h"
#include "wnn_ops_generated.h"

namespace wnn {

struct Dims;
struct DimsBuilder;
struct DimsT;

struct Op;
struct OpBuilder;
struct OpT;

struct Extra;
struct ExtraBuilder;
struct ExtraT;

struct SubGraph;
struct SubGraphBuilder;
struct SubGraphT;

struct TensorQuantInfo;
struct TensorQuantInfoBuilder;
struct TensorQuantInfoT;

struct TensorDescribe;
struct TensorDescribeBuilder;
struct TensorDescribeT;

struct Graph;
struct GraphBuilder;
struct GraphT;

inline const flatbuffers::TypeTable *DimsTypeTable();

inline const flatbuffers::TypeTable *OpTypeTable();

inline const flatbuffers::TypeTable *ExtraTypeTable();

inline const flatbuffers::TypeTable *SubGraphTypeTable();

inline const flatbuffers::TypeTable *TensorQuantInfoTypeTable();

inline const flatbuffers::TypeTable *TensorDescribeTypeTable();

inline const flatbuffers::TypeTable *GraphTypeTable();

enum ModelSource : int8_t {
  ModelSource_TORCH = 0,
  ModelSource_TENSORFLOW = 1,
  ModelSource_ONNX = 2,
  ModelSource_TFLITE = 3,
  ModelSource_MIN = ModelSource_TORCH,
  ModelSource_MAX = ModelSource_TFLITE
};

inline const ModelSource (&EnumValuesModelSource())[4] {
  static const ModelSource values[] = {
    ModelSource_TORCH,
    ModelSource_TENSORFLOW,
    ModelSource_ONNX,
    ModelSource_TFLITE
  };
  return values;
}

inline const char * const *EnumNamesModelSource() {
  static const char * const names[5] = {
    "TORCH",
    "TENSORFLOW",
    "ONNX",
    "TFLITE",
    nullptr
  };
  return names;
}

inline const char *EnumNameModelSource(ModelSource e) {
  if (flatbuffers::IsOutRange(e, ModelSource_TORCH, ModelSource_TFLITE)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesModelSource()[index];
}

enum OpParameter : uint8_t {
  OpParameter_NONE = 0,
  OpParameter_Conv2DCommon = 1,
  OpParameter_Conv2D = 2,
  OpParameter_Pool = 3,
  OpParameter_AdaptiveAvgPool2D = 4,
  OpParameter_LayerNorm = 5,
  OpParameter_BatchNorm = 6,
  OpParameter_Relu = 7,
  OpParameter_Relu6 = 8,
  OpParameter_PRelu = 9,
  OpParameter_ELU = 10,
  OpParameter_LRN = 11,
  OpParameter_Softmax = 12,
  OpParameter_Input = 13,
  OpParameter_Extra = 14,
  OpParameter_FC = 15,
  OpParameter_ArgMax = 16,
  OpParameter_Binary = 17,
  OpParameter_Unary = 18,
  OpParameter_Eltwise = 19,
  OpParameter_Reduction = 20,
  OpParameter_Squeeze = 21,
  OpParameter_Gather = 22,
  OpParameter_ExpandDims = 23,
  OpParameter_Normalize = 24,
  OpParameter_Flatten = 25,
  OpParameter_Blob = 26,
  OpParameter_Permute = 27,
  OpParameter_Reshape = 28,
  OpParameter_Split = 29,
  OpParameter_ChannelShuffle = 30,
  OpParameter_Concat = 31,
  OpParameter_Interpolate = 32,
  OpParameter_Einsum = 33,
  OpParameter_Attribute = 34,
  OpParameter_FilmLPN = 35,
  OpParameter_Cubic = 36,
  OpParameter_MultiHeadAttention = 37,
  OpParameter_Cast = 38,
  OpParameter_Pad = 39,
  OpParameter_Repeat = 40,
  OpParameter_Slice = 41,
  OpParameter_MIN = OpParameter_NONE,
  OpParameter_MAX = OpParameter_Slice
};

inline const OpParameter (&EnumValuesOpParameter())[42] {
  static const OpParameter values[] = {
    OpParameter_NONE,
    OpParameter_Conv2DCommon,
    OpParameter_Conv2D,
    OpParameter_Pool,
    OpParameter_AdaptiveAvgPool2D,
    OpParameter_LayerNorm,
    OpParameter_BatchNorm,
    OpParameter_Relu,
    OpParameter_Relu6,
    OpParameter_PRelu,
    OpParameter_ELU,
    OpParameter_LRN,
    OpParameter_Softmax,
    OpParameter_Input,
    OpParameter_Extra,
    OpParameter_FC,
    OpParameter_ArgMax,
    OpParameter_Binary,
    OpParameter_Unary,
    OpParameter_Eltwise,
    OpParameter_Reduction,
    OpParameter_Squeeze,
    OpParameter_Gather,
    OpParameter_ExpandDims,
    OpParameter_Normalize,
    OpParameter_Flatten,
    OpParameter_Blob,
    OpParameter_Permute,
    OpParameter_Reshape,
    OpParameter_Split,
    OpParameter_ChannelShuffle,
    OpParameter_Concat,
    OpParameter_Interpolate,
    OpParameter_Einsum,
    OpParameter_Attribute,
    OpParameter_FilmLPN,
    OpParameter_Cubic,
    OpParameter_MultiHeadAttention,
    OpParameter_Cast,
    OpParameter_Pad,
    OpParameter_Repeat,
    OpParameter_Slice
  };
  return values;
}

inline const char * const *EnumNamesOpParameter() {
  static const char * const names[43] = {
    "NONE",
    "Conv2DCommon",
    "Conv2D",
    "Pool",
    "AdaptiveAvgPool2D",
    "LayerNorm",
    "BatchNorm",
    "Relu",
    "Relu6",
    "PRelu",
    "ELU",
    "LRN",
    "Softmax",
    "Input",
    "Extra",
    "FC",
    "ArgMax",
    "Binary",
    "Unary",
    "Eltwise",
    "Reduction",
    "Squeeze",
    "Gather",
    "ExpandDims",
    "Normalize",
    "Flatten",
    "Blob",
    "Permute",
    "Reshape",
    "Split",
    "ChannelShuffle",
    "Concat",
    "Interpolate",
    "Einsum",
    "Attribute",
    "FilmLPN",
    "Cubic",
    "MultiHeadAttention",
    "Cast",
    "Pad",
    "Repeat",
    "Slice",
    nullptr
  };
  return names;
}

inline const char *EnumNameOpParameter(OpParameter e) {
  if (flatbuffers::IsOutRange(e, OpParameter_NONE, OpParameter_Slice)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesOpParameter()[index];
}

template<typename T> struct OpParameterTraits {
  static const OpParameter enum_value = OpParameter_NONE;
};

template<> struct OpParameterTraits<wnn::Conv2DCommon> {
  static const OpParameter enum_value = OpParameter_Conv2DCommon;
};

template<> struct OpParameterTraits<wnn::Conv2D> {
  static const OpParameter enum_value = OpParameter_Conv2D;
};

template<> struct OpParameterTraits<wnn::Pool> {
  static const OpParameter enum_value = OpParameter_Pool;
};

template<> struct OpParameterTraits<wnn::AdaptiveAvgPool2D> {
  static const OpParameter enum_value = OpParameter_AdaptiveAvgPool2D;
};

template<> struct OpParameterTraits<wnn::LayerNorm> {
  static const OpParameter enum_value = OpParameter_LayerNorm;
};

template<> struct OpParameterTraits<wnn::BatchNorm> {
  static const OpParameter enum_value = OpParameter_BatchNorm;
};

template<> struct OpParameterTraits<wnn::Relu> {
  static const OpParameter enum_value = OpParameter_Relu;
};

template<> struct OpParameterTraits<wnn::Relu6> {
  static const OpParameter enum_value = OpParameter_Relu6;
};

template<> struct OpParameterTraits<wnn::PRelu> {
  static const OpParameter enum_value = OpParameter_PRelu;
};

template<> struct OpParameterTraits<wnn::ELU> {
  static const OpParameter enum_value = OpParameter_ELU;
};

template<> struct OpParameterTraits<wnn::LRN> {
  static const OpParameter enum_value = OpParameter_LRN;
};

template<> struct OpParameterTraits<wnn::Softmax> {
  static const OpParameter enum_value = OpParameter_Softmax;
};

template<> struct OpParameterTraits<wnn::Input> {
  static const OpParameter enum_value = OpParameter_Input;
};

template<> struct OpParameterTraits<wnn::Extra> {
  static const OpParameter enum_value = OpParameter_Extra;
};

template<> struct OpParameterTraits<wnn::FC> {
  static const OpParameter enum_value = OpParameter_FC;
};

template<> struct OpParameterTraits<wnn::ArgMax> {
  static const OpParameter enum_value = OpParameter_ArgMax;
};

template<> struct OpParameterTraits<wnn::Binary> {
  static const OpParameter enum_value = OpParameter_Binary;
};

template<> struct OpParameterTraits<wnn::Unary> {
  static const OpParameter enum_value = OpParameter_Unary;
};

template<> struct OpParameterTraits<wnn::Eltwise> {
  static const OpParameter enum_value = OpParameter_Eltwise;
};

template<> struct OpParameterTraits<wnn::Reduction> {
  static const OpParameter enum_value = OpParameter_Reduction;
};

template<> struct OpParameterTraits<wnn::Squeeze> {
  static const OpParameter enum_value = OpParameter_Squeeze;
};

template<> struct OpParameterTraits<wnn::Gather> {
  static const OpParameter enum_value = OpParameter_Gather;
};

template<> struct OpParameterTraits<wnn::ExpandDims> {
  static const OpParameter enum_value = OpParameter_ExpandDims;
};

template<> struct OpParameterTraits<wnn::Normalize> {
  static const OpParameter enum_value = OpParameter_Normalize;
};

template<> struct OpParameterTraits<wnn::Flatten> {
  static const OpParameter enum_value = OpParameter_Flatten;
};

template<> struct OpParameterTraits<wnn::Blob> {
  static const OpParameter enum_value = OpParameter_Blob;
};

template<> struct OpParameterTraits<wnn::Permute> {
  static const OpParameter enum_value = OpParameter_Permute;
};

template<> struct OpParameterTraits<wnn::Reshape> {
  static const OpParameter enum_value = OpParameter_Reshape;
};

template<> struct OpParameterTraits<wnn::Split> {
  static const OpParameter enum_value = OpParameter_Split;
};

template<> struct OpParameterTraits<wnn::ChannelShuffle> {
  static const OpParameter enum_value = OpParameter_ChannelShuffle;
};

template<> struct OpParameterTraits<wnn::Concat> {
  static const OpParameter enum_value = OpParameter_Concat;
};

template<> struct OpParameterTraits<wnn::Interpolate> {
  static const OpParameter enum_value = OpParameter_Interpolate;
};

template<> struct OpParameterTraits<wnn::Einsum> {
  static const OpParameter enum_value = OpParameter_Einsum;
};

template<> struct OpParameterTraits<wnn::Attribute> {
  static const OpParameter enum_value = OpParameter_Attribute;
};

template<> struct OpParameterTraits<wnn::FilmLPN> {
  static const OpParameter enum_value = OpParameter_FilmLPN;
};

template<> struct OpParameterTraits<wnn::Cubic> {
  static const OpParameter enum_value = OpParameter_Cubic;
};

template<> struct OpParameterTraits<wnn::MultiHeadAttention> {
  static const OpParameter enum_value = OpParameter_MultiHeadAttention;
};

template<> struct OpParameterTraits<wnn::Cast> {
  static const OpParameter enum_value = OpParameter_Cast;
};

template<> struct OpParameterTraits<wnn::Pad> {
  static const OpParameter enum_value = OpParameter_Pad;
};

template<> struct OpParameterTraits<wnn::Repeat> {
  static const OpParameter enum_value = OpParameter_Repeat;
};

template<> struct OpParameterTraits<wnn::Slice> {
  static const OpParameter enum_value = OpParameter_Slice;
};

template<typename T> struct OpParameterUnionTraits {
  static const OpParameter enum_value = OpParameter_NONE;
};

template<> struct OpParameterUnionTraits<wnn::Conv2DCommonT> {
  static const OpParameter enum_value = OpParameter_Conv2DCommon;
};

template<> struct OpParameterUnionTraits<wnn::Conv2DT> {
  static const OpParameter enum_value = OpParameter_Conv2D;
};

template<> struct OpParameterUnionTraits<wnn::PoolT> {
  static const OpParameter enum_value = OpParameter_Pool;
};

template<> struct OpParameterUnionTraits<wnn::AdaptiveAvgPool2DT> {
  static const OpParameter enum_value = OpParameter_AdaptiveAvgPool2D;
};

template<> struct OpParameterUnionTraits<wnn::LayerNormT> {
  static const OpParameter enum_value = OpParameter_LayerNorm;
};

template<> struct OpParameterUnionTraits<wnn::BatchNormT> {
  static const OpParameter enum_value = OpParameter_BatchNorm;
};

template<> struct OpParameterUnionTraits<wnn::ReluT> {
  static const OpParameter enum_value = OpParameter_Relu;
};

template<> struct OpParameterUnionTraits<wnn::Relu6T> {
  static const OpParameter enum_value = OpParameter_Relu6;
};

template<> struct OpParameterUnionTraits<wnn::PReluT> {
  static const OpParameter enum_value = OpParameter_PRelu;
};

template<> struct OpParameterUnionTraits<wnn::ELUT> {
  static const OpParameter enum_value = OpParameter_ELU;
};

template<> struct OpParameterUnionTraits<wnn::LRNT> {
  static const OpParameter enum_value = OpParameter_LRN;
};

template<> struct OpParameterUnionTraits<wnn::SoftmaxT> {
  static const OpParameter enum_value = OpParameter_Softmax;
};

template<> struct OpParameterUnionTraits<wnn::InputT> {
  static const OpParameter enum_value = OpParameter_Input;
};

template<> struct OpParameterUnionTraits<wnn::ExtraT> {
  static const OpParameter enum_value = OpParameter_Extra;
};

template<> struct OpParameterUnionTraits<wnn::FCT> {
  static const OpParameter enum_value = OpParameter_FC;
};

template<> struct OpParameterUnionTraits<wnn::ArgMaxT> {
  static const OpParameter enum_value = OpParameter_ArgMax;
};

template<> struct OpParameterUnionTraits<wnn::BinaryT> {
  static const OpParameter enum_value = OpParameter_Binary;
};

template<> struct OpParameterUnionTraits<wnn::UnaryT> {
  static const OpParameter enum_value = OpParameter_Unary;
};

template<> struct OpParameterUnionTraits<wnn::EltwiseT> {
  static const OpParameter enum_value = OpParameter_Eltwise;
};

template<> struct OpParameterUnionTraits<wnn::ReductionT> {
  static const OpParameter enum_value = OpParameter_Reduction;
};

template<> struct OpParameterUnionTraits<wnn::SqueezeT> {
  static const OpParameter enum_value = OpParameter_Squeeze;
};

template<> struct OpParameterUnionTraits<wnn::GatherT> {
  static const OpParameter enum_value = OpParameter_Gather;
};

template<> struct OpParameterUnionTraits<wnn::ExpandDimsT> {
  static const OpParameter enum_value = OpParameter_ExpandDims;
};

template<> struct OpParameterUnionTraits<wnn::NormalizeT> {
  static const OpParameter enum_value = OpParameter_Normalize;
};

template<> struct OpParameterUnionTraits<wnn::FlattenT> {
  static const OpParameter enum_value = OpParameter_Flatten;
};

template<> struct OpParameterUnionTraits<wnn::BlobT> {
  static const OpParameter enum_value = OpParameter_Blob;
};

template<> struct OpParameterUnionTraits<wnn::PermuteT> {
  static const OpParameter enum_value = OpParameter_Permute;
};

template<> struct OpParameterUnionTraits<wnn::ReshapeT> {
  static const OpParameter enum_value = OpParameter_Reshape;
};

template<> struct OpParameterUnionTraits<wnn::SplitT> {
  static const OpParameter enum_value = OpParameter_Split;
};

template<> struct OpParameterUnionTraits<wnn::ChannelShuffleT> {
  static const OpParameter enum_value = OpParameter_ChannelShuffle;
};

template<> struct OpParameterUnionTraits<wnn::ConcatT> {
  static const OpParameter enum_value = OpParameter_Concat;
};

template<> struct OpParameterUnionTraits<wnn::InterpolateT> {
  static const OpParameter enum_value = OpParameter_Interpolate;
};

template<> struct OpParameterUnionTraits<wnn::EinsumT> {
  static const OpParameter enum_value = OpParameter_Einsum;
};

template<> struct OpParameterUnionTraits<wnn::AttributeT> {
  static const OpParameter enum_value = OpParameter_Attribute;
};

template<> struct OpParameterUnionTraits<wnn::FilmLPNT> {
  static const OpParameter enum_value = OpParameter_FilmLPN;
};

template<> struct OpParameterUnionTraits<wnn::CubicT> {
  static const OpParameter enum_value = OpParameter_Cubic;
};

template<> struct OpParameterUnionTraits<wnn::MultiHeadAttentionT> {
  static const OpParameter enum_value = OpParameter_MultiHeadAttention;
};

template<> struct OpParameterUnionTraits<wnn::CastT> {
  static const OpParameter enum_value = OpParameter_Cast;
};

template<> struct OpParameterUnionTraits<wnn::PadT> {
  static const OpParameter enum_value = OpParameter_Pad;
};

template<> struct OpParameterUnionTraits<wnn::RepeatT> {
  static const OpParameter enum_value = OpParameter_Repeat;
};

template<> struct OpParameterUnionTraits<wnn::SliceT> {
  static const OpParameter enum_value = OpParameter_Slice;
};

struct OpParameterUnion {
  OpParameter type;
  void *value;

  OpParameterUnion() : type(OpParameter_NONE), value(nullptr) {}
  OpParameterUnion(OpParameterUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(OpParameter_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  OpParameterUnion(const OpParameterUnion &);
  OpParameterUnion &operator=(const OpParameterUnion &u)
    { OpParameterUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  OpParameterUnion &operator=(OpParameterUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~OpParameterUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = OpParameterUnionTraits<RT>::enum_value;
    if (type != OpParameter_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, OpParameter type, const flatbuffers::resolver_function_t *resolver);
  flatbuffers::Offset<void> Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  wnn::Conv2DCommonT *AsConv2DCommon() {
    return type == OpParameter_Conv2DCommon ?
      reinterpret_cast<wnn::Conv2DCommonT *>(value) : nullptr;
  }
  const wnn::Conv2DCommonT *AsConv2DCommon() const {
    return type == OpParameter_Conv2DCommon ?
      reinterpret_cast<const wnn::Conv2DCommonT *>(value) : nullptr;
  }
  wnn::Conv2DT *AsConv2D() {
    return type == OpParameter_Conv2D ?
      reinterpret_cast<wnn::Conv2DT *>(value) : nullptr;
  }
  const wnn::Conv2DT *AsConv2D() const {
    return type == OpParameter_Conv2D ?
      reinterpret_cast<const wnn::Conv2DT *>(value) : nullptr;
  }
  wnn::PoolT *AsPool() {
    return type == OpParameter_Pool ?
      reinterpret_cast<wnn::PoolT *>(value) : nullptr;
  }
  const wnn::PoolT *AsPool() const {
    return type == OpParameter_Pool ?
      reinterpret_cast<const wnn::PoolT *>(value) : nullptr;
  }
  wnn::AdaptiveAvgPool2DT *AsAdaptiveAvgPool2D() {
    return type == OpParameter_AdaptiveAvgPool2D ?
      reinterpret_cast<wnn::AdaptiveAvgPool2DT *>(value) : nullptr;
  }
  const wnn::AdaptiveAvgPool2DT *AsAdaptiveAvgPool2D() const {
    return type == OpParameter_AdaptiveAvgPool2D ?
      reinterpret_cast<const wnn::AdaptiveAvgPool2DT *>(value) : nullptr;
  }
  wnn::LayerNormT *AsLayerNorm() {
    return type == OpParameter_LayerNorm ?
      reinterpret_cast<wnn::LayerNormT *>(value) : nullptr;
  }
  const wnn::LayerNormT *AsLayerNorm() const {
    return type == OpParameter_LayerNorm ?
      reinterpret_cast<const wnn::LayerNormT *>(value) : nullptr;
  }
  wnn::BatchNormT *AsBatchNorm() {
    return type == OpParameter_BatchNorm ?
      reinterpret_cast<wnn::BatchNormT *>(value) : nullptr;
  }
  const wnn::BatchNormT *AsBatchNorm() const {
    return type == OpParameter_BatchNorm ?
      reinterpret_cast<const wnn::BatchNormT *>(value) : nullptr;
  }
  wnn::ReluT *AsRelu() {
    return type == OpParameter_Relu ?
      reinterpret_cast<wnn::ReluT *>(value) : nullptr;
  }
  const wnn::ReluT *AsRelu() const {
    return type == OpParameter_Relu ?
      reinterpret_cast<const wnn::ReluT *>(value) : nullptr;
  }
  wnn::Relu6T *AsRelu6() {
    return type == OpParameter_Relu6 ?
      reinterpret_cast<wnn::Relu6T *>(value) : nullptr;
  }
  const wnn::Relu6T *AsRelu6() const {
    return type == OpParameter_Relu6 ?
      reinterpret_cast<const wnn::Relu6T *>(value) : nullptr;
  }
  wnn::PReluT *AsPRelu() {
    return type == OpParameter_PRelu ?
      reinterpret_cast<wnn::PReluT *>(value) : nullptr;
  }
  const wnn::PReluT *AsPRelu() const {
    return type == OpParameter_PRelu ?
      reinterpret_cast<const wnn::PReluT *>(value) : nullptr;
  }
  wnn::ELUT *AsELU() {
    return type == OpParameter_ELU ?
      reinterpret_cast<wnn::ELUT *>(value) : nullptr;
  }
  const wnn::ELUT *AsELU() const {
    return type == OpParameter_ELU ?
      reinterpret_cast<const wnn::ELUT *>(value) : nullptr;
  }
  wnn::LRNT *AsLRN() {
    return type == OpParameter_LRN ?
      reinterpret_cast<wnn::LRNT *>(value) : nullptr;
  }
  const wnn::LRNT *AsLRN() const {
    return type == OpParameter_LRN ?
      reinterpret_cast<const wnn::LRNT *>(value) : nullptr;
  }
  wnn::SoftmaxT *AsSoftmax() {
    return type == OpParameter_Softmax ?
      reinterpret_cast<wnn::SoftmaxT *>(value) : nullptr;
  }
  const wnn::SoftmaxT *AsSoftmax() const {
    return type == OpParameter_Softmax ?
      reinterpret_cast<const wnn::SoftmaxT *>(value) : nullptr;
  }
  wnn::InputT *AsInput() {
    return type == OpParameter_Input ?
      reinterpret_cast<wnn::InputT *>(value) : nullptr;
  }
  const wnn::InputT *AsInput() const {
    return type == OpParameter_Input ?
      reinterpret_cast<const wnn::InputT *>(value) : nullptr;
  }
  wnn::ExtraT *AsExtra() {
    return type == OpParameter_Extra ?
      reinterpret_cast<wnn::ExtraT *>(value) : nullptr;
  }
  const wnn::ExtraT *AsExtra() const {
    return type == OpParameter_Extra ?
      reinterpret_cast<const wnn::ExtraT *>(value) : nullptr;
  }
  wnn::FCT *AsFC() {
    return type == OpParameter_FC ?
      reinterpret_cast<wnn::FCT *>(value) : nullptr;
  }
  const wnn::FCT *AsFC() const {
    return type == OpParameter_FC ?
      reinterpret_cast<const wnn::FCT *>(value) : nullptr;
  }
  wnn::ArgMaxT *AsArgMax() {
    return type == OpParameter_ArgMax ?
      reinterpret_cast<wnn::ArgMaxT *>(value) : nullptr;
  }
  const wnn::ArgMaxT *AsArgMax() const {
    return type == OpParameter_ArgMax ?
      reinterpret_cast<const wnn::ArgMaxT *>(value) : nullptr;
  }
  wnn::BinaryT *AsBinary() {
    return type == OpParameter_Binary ?
      reinterpret_cast<wnn::BinaryT *>(value) : nullptr;
  }
  const wnn::BinaryT *AsBinary() const {
    return type == OpParameter_Binary ?
      reinterpret_cast<const wnn::BinaryT *>(value) : nullptr;
  }
  wnn::UnaryT *AsUnary() {
    return type == OpParameter_Unary ?
      reinterpret_cast<wnn::UnaryT *>(value) : nullptr;
  }
  const wnn::UnaryT *AsUnary() const {
    return type == OpParameter_Unary ?
      reinterpret_cast<const wnn::UnaryT *>(value) : nullptr;
  }
  wnn::EltwiseT *AsEltwise() {
    return type == OpParameter_Eltwise ?
      reinterpret_cast<wnn::EltwiseT *>(value) : nullptr;
  }
  const wnn::EltwiseT *AsEltwise() const {
    return type == OpParameter_Eltwise ?
      reinterpret_cast<const wnn::EltwiseT *>(value) : nullptr;
  }
  wnn::ReductionT *AsReduction() {
    return type == OpParameter_Reduction ?
      reinterpret_cast<wnn::ReductionT *>(value) : nullptr;
  }
  const wnn::ReductionT *AsReduction() const {
    return type == OpParameter_Reduction ?
      reinterpret_cast<const wnn::ReductionT *>(value) : nullptr;
  }
  wnn::SqueezeT *AsSqueeze() {
    return type == OpParameter_Squeeze ?
      reinterpret_cast<wnn::SqueezeT *>(value) : nullptr;
  }
  const wnn::SqueezeT *AsSqueeze() const {
    return type == OpParameter_Squeeze ?
      reinterpret_cast<const wnn::SqueezeT *>(value) : nullptr;
  }
  wnn::GatherT *AsGather() {
    return type == OpParameter_Gather ?
      reinterpret_cast<wnn::GatherT *>(value) : nullptr;
  }
  const wnn::GatherT *AsGather() const {
    return type == OpParameter_Gather ?
      reinterpret_cast<const wnn::GatherT *>(value) : nullptr;
  }
  wnn::ExpandDimsT *AsExpandDims() {
    return type == OpParameter_ExpandDims ?
      reinterpret_cast<wnn::ExpandDimsT *>(value) : nullptr;
  }
  const wnn::ExpandDimsT *AsExpandDims() const {
    return type == OpParameter_ExpandDims ?
      reinterpret_cast<const wnn::ExpandDimsT *>(value) : nullptr;
  }
  wnn::NormalizeT *AsNormalize() {
    return type == OpParameter_Normalize ?
      reinterpret_cast<wnn::NormalizeT *>(value) : nullptr;
  }
  const wnn::NormalizeT *AsNormalize() const {
    return type == OpParameter_Normalize ?
      reinterpret_cast<const wnn::NormalizeT *>(value) : nullptr;
  }
  wnn::FlattenT *AsFlatten() {
    return type == OpParameter_Flatten ?
      reinterpret_cast<wnn::FlattenT *>(value) : nullptr;
  }
  const wnn::FlattenT *AsFlatten() const {
    return type == OpParameter_Flatten ?
      reinterpret_cast<const wnn::FlattenT *>(value) : nullptr;
  }
  wnn::BlobT *AsBlob() {
    return type == OpParameter_Blob ?
      reinterpret_cast<wnn::BlobT *>(value) : nullptr;
  }
  const wnn::BlobT *AsBlob() const {
    return type == OpParameter_Blob ?
      reinterpret_cast<const wnn::BlobT *>(value) : nullptr;
  }
  wnn::PermuteT *AsPermute() {
    return type == OpParameter_Permute ?
      reinterpret_cast<wnn::PermuteT *>(value) : nullptr;
  }
  const wnn::PermuteT *AsPermute() const {
    return type == OpParameter_Permute ?
      reinterpret_cast<const wnn::PermuteT *>(value) : nullptr;
  }
  wnn::ReshapeT *AsReshape() {
    return type == OpParameter_Reshape ?
      reinterpret_cast<wnn::ReshapeT *>(value) : nullptr;
  }
  const wnn::ReshapeT *AsReshape() const {
    return type == OpParameter_Reshape ?
      reinterpret_cast<const wnn::ReshapeT *>(value) : nullptr;
  }
  wnn::SplitT *AsSplit() {
    return type == OpParameter_Split ?
      reinterpret_cast<wnn::SplitT *>(value) : nullptr;
  }
  const wnn::SplitT *AsSplit() const {
    return type == OpParameter_Split ?
      reinterpret_cast<const wnn::SplitT *>(value) : nullptr;
  }
  wnn::ChannelShuffleT *AsChannelShuffle() {
    return type == OpParameter_ChannelShuffle ?
      reinterpret_cast<wnn::ChannelShuffleT *>(value) : nullptr;
  }
  const wnn::ChannelShuffleT *AsChannelShuffle() const {
    return type == OpParameter_ChannelShuffle ?
      reinterpret_cast<const wnn::ChannelShuffleT *>(value) : nullptr;
  }
  wnn::ConcatT *AsConcat() {
    return type == OpParameter_Concat ?
      reinterpret_cast<wnn::ConcatT *>(value) : nullptr;
  }
  const wnn::ConcatT *AsConcat() const {
    return type == OpParameter_Concat ?
      reinterpret_cast<const wnn::ConcatT *>(value) : nullptr;
  }
  wnn::InterpolateT *AsInterpolate() {
    return type == OpParameter_Interpolate ?
      reinterpret_cast<wnn::InterpolateT *>(value) : nullptr;
  }
  const wnn::InterpolateT *AsInterpolate() const {
    return type == OpParameter_Interpolate ?
      reinterpret_cast<const wnn::InterpolateT *>(value) : nullptr;
  }
  wnn::EinsumT *AsEinsum() {
    return type == OpParameter_Einsum ?
      reinterpret_cast<wnn::EinsumT *>(value) : nullptr;
  }
  const wnn::EinsumT *AsEinsum() const {
    return type == OpParameter_Einsum ?
      reinterpret_cast<const wnn::EinsumT *>(value) : nullptr;
  }
  wnn::AttributeT *AsAttribute() {
    return type == OpParameter_Attribute ?
      reinterpret_cast<wnn::AttributeT *>(value) : nullptr;
  }
  const wnn::AttributeT *AsAttribute() const {
    return type == OpParameter_Attribute ?
      reinterpret_cast<const wnn::AttributeT *>(value) : nullptr;
  }
  wnn::FilmLPNT *AsFilmLPN() {
    return type == OpParameter_FilmLPN ?
      reinterpret_cast<wnn::FilmLPNT *>(value) : nullptr;
  }
  const wnn::FilmLPNT *AsFilmLPN() const {
    return type == OpParameter_FilmLPN ?
      reinterpret_cast<const wnn::FilmLPNT *>(value) : nullptr;
  }
  wnn::CubicT *AsCubic() {
    return type == OpParameter_Cubic ?
      reinterpret_cast<wnn::CubicT *>(value) : nullptr;
  }
  const wnn::CubicT *AsCubic() const {
    return type == OpParameter_Cubic ?
      reinterpret_cast<const wnn::CubicT *>(value) : nullptr;
  }
  wnn::MultiHeadAttentionT *AsMultiHeadAttention() {
    return type == OpParameter_MultiHeadAttention ?
      reinterpret_cast<wnn::MultiHeadAttentionT *>(value) : nullptr;
  }
  const wnn::MultiHeadAttentionT *AsMultiHeadAttention() const {
    return type == OpParameter_MultiHeadAttention ?
      reinterpret_cast<const wnn::MultiHeadAttentionT *>(value) : nullptr;
  }
  wnn::CastT *AsCast() {
    return type == OpParameter_Cast ?
      reinterpret_cast<wnn::CastT *>(value) : nullptr;
  }
  const wnn::CastT *AsCast() const {
    return type == OpParameter_Cast ?
      reinterpret_cast<const wnn::CastT *>(value) : nullptr;
  }
  wnn::PadT *AsPad() {
    return type == OpParameter_Pad ?
      reinterpret_cast<wnn::PadT *>(value) : nullptr;
  }
  const wnn::PadT *AsPad() const {
    return type == OpParameter_Pad ?
      reinterpret_cast<const wnn::PadT *>(value) : nullptr;
  }
  wnn::RepeatT *AsRepeat() {
    return type == OpParameter_Repeat ?
      reinterpret_cast<wnn::RepeatT *>(value) : nullptr;
  }
  const wnn::RepeatT *AsRepeat() const {
    return type == OpParameter_Repeat ?
      reinterpret_cast<const wnn::RepeatT *>(value) : nullptr;
  }
  wnn::SliceT *AsSlice() {
    return type == OpParameter_Slice ?
      reinterpret_cast<wnn::SliceT *>(value) : nullptr;
  }
  const wnn::SliceT *AsSlice() const {
    return type == OpParameter_Slice ?
      reinterpret_cast<const wnn::SliceT *>(value) : nullptr;
  }
};

bool VerifyOpParameter(flatbuffers::Verifier &verifier, const void *obj, OpParameter type);
bool VerifyOpParameterVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct DimsT : public flatbuffers::NativeTable {
  typedef Dims TableType;
  std::vector<int32_t> shape{};
  int32_t total_size = 0;
};

struct Dims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef DimsT NativeTableType;
  typedef DimsBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return DimsTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SHAPE = 4,
    VT_TOTAL_SIZE = 6
  };
  const flatbuffers::Vector<int32_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SHAPE);
  }
  int32_t total_size() const {
    return GetField<int32_t>(VT_TOTAL_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int32_t>(verifier, VT_TOTAL_SIZE, 4) &&
           verifier.EndTable();
  }
  DimsT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(DimsT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Dims> Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimsT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct DimsBuilder {
  typedef Dims Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape) {
    fbb_.AddOffset(Dims::VT_SHAPE, shape);
  }
  void add_total_size(int32_t total_size) {
    fbb_.AddElement<int32_t>(Dims::VT_TOTAL_SIZE, total_size, 0);
  }
  explicit DimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Dims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dims>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dims> CreateDims(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> shape = 0,
    int32_t total_size = 0) {
  DimsBuilder builder_(_fbb);
  builder_.add_total_size(total_size);
  builder_.add_shape(shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<Dims> CreateDimsDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *shape = nullptr,
    int32_t total_size = 0) {
  auto shape__ = shape ? _fbb.CreateVector<int32_t>(*shape) : 0;
  return wnn::CreateDims(
      _fbb,
      shape__,
      total_size);
}

flatbuffers::Offset<Dims> CreateDims(flatbuffers::FlatBufferBuilder &_fbb, const DimsT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct OpT : public flatbuffers::NativeTable {
  typedef Op TableType;
  std::vector<int32_t> input_indexes{};
  std::vector<int32_t> output_indexes{};
  std::vector<std::string> input_names{};
  std::vector<std::string> output_names{};
  std::vector<std::unique_ptr<wnn::DimsT>> input_shapes{};
  std::vector<std::unique_ptr<wnn::DimsT>> output_shapes{};
  bool is_static_shape = false;
  wnn::OpParameterUnion param{};
  std::string name{};
  wnn::OpType type = wnn::OpType_argmax;
  OpT() = default;
  OpT(const OpT &o);
  OpT(OpT&&) FLATBUFFERS_NOEXCEPT = default;
  OpT &operator=(OpT o) FLATBUFFERS_NOEXCEPT;
};

struct Op FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef OpT NativeTableType;
  typedef OpBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return OpTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_INDEXES = 4,
    VT_OUTPUT_INDEXES = 6,
    VT_INPUT_NAMES = 8,
    VT_OUTPUT_NAMES = 10,
    VT_INPUT_SHAPES = 12,
    VT_OUTPUT_SHAPES = 14,
    VT_IS_STATIC_SHAPE = 16,
    VT_PARAM_TYPE = 18,
    VT_PARAM = 20,
    VT_NAME = 22,
    VT_TYPE = 24
  };
  const flatbuffers::Vector<int32_t> *input_indexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_INDEXES);
  }
  const flatbuffers::Vector<int32_t> *output_indexes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUT_INDEXES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *input_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUT_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *output_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUT_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<wnn::Dims>> *input_shapes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<wnn::Dims>> *>(VT_INPUT_SHAPES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<wnn::Dims>> *output_shapes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<wnn::Dims>> *>(VT_OUTPUT_SHAPES);
  }
  bool is_static_shape() const {
    return GetField<uint8_t>(VT_IS_STATIC_SHAPE, 0) != 0;
  }
  wnn::OpParameter param_type() const {
    return static_cast<wnn::OpParameter>(GetField<uint8_t>(VT_PARAM_TYPE, 0));
  }
  const void *param() const {
    return GetPointer<const void *>(VT_PARAM);
  }
  template<typename T> const T *param_as() const;
  const wnn::Conv2DCommon *param_as_Conv2DCommon() const {
    return param_type() == wnn::OpParameter_Conv2DCommon ? static_cast<const wnn::Conv2DCommon *>(param()) : nullptr;
  }
  const wnn::Conv2D *param_as_Conv2D() const {
    return param_type() == wnn::OpParameter_Conv2D ? static_cast<const wnn::Conv2D *>(param()) : nullptr;
  }
  const wnn::Pool *param_as_Pool() const {
    return param_type() == wnn::OpParameter_Pool ? static_cast<const wnn::Pool *>(param()) : nullptr;
  }
  const wnn::AdaptiveAvgPool2D *param_as_AdaptiveAvgPool2D() const {
    return param_type() == wnn::OpParameter_AdaptiveAvgPool2D ? static_cast<const wnn::AdaptiveAvgPool2D *>(param()) : nullptr;
  }
  const wnn::LayerNorm *param_as_LayerNorm() const {
    return param_type() == wnn::OpParameter_LayerNorm ? static_cast<const wnn::LayerNorm *>(param()) : nullptr;
  }
  const wnn::BatchNorm *param_as_BatchNorm() const {
    return param_type() == wnn::OpParameter_BatchNorm ? static_cast<const wnn::BatchNorm *>(param()) : nullptr;
  }
  const wnn::Relu *param_as_Relu() const {
    return param_type() == wnn::OpParameter_Relu ? static_cast<const wnn::Relu *>(param()) : nullptr;
  }
  const wnn::Relu6 *param_as_Relu6() const {
    return param_type() == wnn::OpParameter_Relu6 ? static_cast<const wnn::Relu6 *>(param()) : nullptr;
  }
  const wnn::PRelu *param_as_PRelu() const {
    return param_type() == wnn::OpParameter_PRelu ? static_cast<const wnn::PRelu *>(param()) : nullptr;
  }
  const wnn::ELU *param_as_ELU() const {
    return param_type() == wnn::OpParameter_ELU ? static_cast<const wnn::ELU *>(param()) : nullptr;
  }
  const wnn::LRN *param_as_LRN() const {
    return param_type() == wnn::OpParameter_LRN ? static_cast<const wnn::LRN *>(param()) : nullptr;
  }
  const wnn::Softmax *param_as_Softmax() const {
    return param_type() == wnn::OpParameter_Softmax ? static_cast<const wnn::Softmax *>(param()) : nullptr;
  }
  const wnn::Input *param_as_Input() const {
    return param_type() == wnn::OpParameter_Input ? static_cast<const wnn::Input *>(param()) : nullptr;
  }
  const wnn::Extra *param_as_Extra() const {
    return param_type() == wnn::OpParameter_Extra ? static_cast<const wnn::Extra *>(param()) : nullptr;
  }
  const wnn::FC *param_as_FC() const {
    return param_type() == wnn::OpParameter_FC ? static_cast<const wnn::FC *>(param()) : nullptr;
  }
  const wnn::ArgMax *param_as_ArgMax() const {
    return param_type() == wnn::OpParameter_ArgMax ? static_cast<const wnn::ArgMax *>(param()) : nullptr;
  }
  const wnn::Binary *param_as_Binary() const {
    return param_type() == wnn::OpParameter_Binary ? static_cast<const wnn::Binary *>(param()) : nullptr;
  }
  const wnn::Unary *param_as_Unary() const {
    return param_type() == wnn::OpParameter_Unary ? static_cast<const wnn::Unary *>(param()) : nullptr;
  }
  const wnn::Eltwise *param_as_Eltwise() const {
    return param_type() == wnn::OpParameter_Eltwise ? static_cast<const wnn::Eltwise *>(param()) : nullptr;
  }
  const wnn::Reduction *param_as_Reduction() const {
    return param_type() == wnn::OpParameter_Reduction ? static_cast<const wnn::Reduction *>(param()) : nullptr;
  }
  const wnn::Squeeze *param_as_Squeeze() const {
    return param_type() == wnn::OpParameter_Squeeze ? static_cast<const wnn::Squeeze *>(param()) : nullptr;
  }
  const wnn::Gather *param_as_Gather() const {
    return param_type() == wnn::OpParameter_Gather ? static_cast<const wnn::Gather *>(param()) : nullptr;
  }
  const wnn::ExpandDims *param_as_ExpandDims() const {
    return param_type() == wnn::OpParameter_ExpandDims ? static_cast<const wnn::ExpandDims *>(param()) : nullptr;
  }
  const wnn::Normalize *param_as_Normalize() const {
    return param_type() == wnn::OpParameter_Normalize ? static_cast<const wnn::Normalize *>(param()) : nullptr;
  }
  const wnn::Flatten *param_as_Flatten() const {
    return param_type() == wnn::OpParameter_Flatten ? static_cast<const wnn::Flatten *>(param()) : nullptr;
  }
  const wnn::Blob *param_as_Blob() const {
    return param_type() == wnn::OpParameter_Blob ? static_cast<const wnn::Blob *>(param()) : nullptr;
  }
  const wnn::Permute *param_as_Permute() const {
    return param_type() == wnn::OpParameter_Permute ? static_cast<const wnn::Permute *>(param()) : nullptr;
  }
  const wnn::Reshape *param_as_Reshape() const {
    return param_type() == wnn::OpParameter_Reshape ? static_cast<const wnn::Reshape *>(param()) : nullptr;
  }
  const wnn::Split *param_as_Split() const {
    return param_type() == wnn::OpParameter_Split ? static_cast<const wnn::Split *>(param()) : nullptr;
  }
  const wnn::ChannelShuffle *param_as_ChannelShuffle() const {
    return param_type() == wnn::OpParameter_ChannelShuffle ? static_cast<const wnn::ChannelShuffle *>(param()) : nullptr;
  }
  const wnn::Concat *param_as_Concat() const {
    return param_type() == wnn::OpParameter_Concat ? static_cast<const wnn::Concat *>(param()) : nullptr;
  }
  const wnn::Interpolate *param_as_Interpolate() const {
    return param_type() == wnn::OpParameter_Interpolate ? static_cast<const wnn::Interpolate *>(param()) : nullptr;
  }
  const wnn::Einsum *param_as_Einsum() const {
    return param_type() == wnn::OpParameter_Einsum ? static_cast<const wnn::Einsum *>(param()) : nullptr;
  }
  const wnn::Attribute *param_as_Attribute() const {
    return param_type() == wnn::OpParameter_Attribute ? static_cast<const wnn::Attribute *>(param()) : nullptr;
  }
  const wnn::FilmLPN *param_as_FilmLPN() const {
    return param_type() == wnn::OpParameter_FilmLPN ? static_cast<const wnn::FilmLPN *>(param()) : nullptr;
  }
  const wnn::Cubic *param_as_Cubic() const {
    return param_type() == wnn::OpParameter_Cubic ? static_cast<const wnn::Cubic *>(param()) : nullptr;
  }
  const wnn::MultiHeadAttention *param_as_MultiHeadAttention() const {
    return param_type() == wnn::OpParameter_MultiHeadAttention ? static_cast<const wnn::MultiHeadAttention *>(param()) : nullptr;
  }
  const wnn::Cast *param_as_Cast() const {
    return param_type() == wnn::OpParameter_Cast ? static_cast<const wnn::Cast *>(param()) : nullptr;
  }
  const wnn::Pad *param_as_Pad() const {
    return param_type() == wnn::OpParameter_Pad ? static_cast<const wnn::Pad *>(param()) : nullptr;
  }
  const wnn::Repeat *param_as_Repeat() const {
    return param_type() == wnn::OpParameter_Repeat ? static_cast<const wnn::Repeat *>(param()) : nullptr;
  }
  const wnn::Slice *param_as_Slice() const {
    return param_type() == wnn::OpParameter_Slice ? static_cast<const wnn::Slice *>(param()) : nullptr;
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  wnn::OpType type() const {
    return static_cast<wnn::OpType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT_INDEXES) &&
           verifier.VerifyVector(input_indexes()) &&
           VerifyOffset(verifier, VT_OUTPUT_INDEXES) &&
           verifier.VerifyVector(output_indexes()) &&
           VerifyOffset(verifier, VT_INPUT_NAMES) &&
           verifier.VerifyVector(input_names()) &&
           verifier.VerifyVectorOfStrings(input_names()) &&
           VerifyOffset(verifier, VT_OUTPUT_NAMES) &&
           verifier.VerifyVector(output_names()) &&
           verifier.VerifyVectorOfStrings(output_names()) &&
           VerifyOffset(verifier, VT_INPUT_SHAPES) &&
           verifier.VerifyVector(input_shapes()) &&
           verifier.VerifyVectorOfTables(input_shapes()) &&
           VerifyOffset(verifier, VT_OUTPUT_SHAPES) &&
           verifier.VerifyVector(output_shapes()) &&
           verifier.VerifyVectorOfTables(output_shapes()) &&
           VerifyField<uint8_t>(verifier, VT_IS_STATIC_SHAPE, 1) &&
           VerifyField<uint8_t>(verifier, VT_PARAM_TYPE, 1) &&
           VerifyOffset(verifier, VT_PARAM) &&
           VerifyOpParameter(verifier, param(), param_type()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
  OpT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(OpT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Op> Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const wnn::Conv2DCommon *Op::param_as<wnn::Conv2DCommon>() const {
  return param_as_Conv2DCommon();
}

template<> inline const wnn::Conv2D *Op::param_as<wnn::Conv2D>() const {
  return param_as_Conv2D();
}

template<> inline const wnn::Pool *Op::param_as<wnn::Pool>() const {
  return param_as_Pool();
}

template<> inline const wnn::AdaptiveAvgPool2D *Op::param_as<wnn::AdaptiveAvgPool2D>() const {
  return param_as_AdaptiveAvgPool2D();
}

template<> inline const wnn::LayerNorm *Op::param_as<wnn::LayerNorm>() const {
  return param_as_LayerNorm();
}

template<> inline const wnn::BatchNorm *Op::param_as<wnn::BatchNorm>() const {
  return param_as_BatchNorm();
}

template<> inline const wnn::Relu *Op::param_as<wnn::Relu>() const {
  return param_as_Relu();
}

template<> inline const wnn::Relu6 *Op::param_as<wnn::Relu6>() const {
  return param_as_Relu6();
}

template<> inline const wnn::PRelu *Op::param_as<wnn::PRelu>() const {
  return param_as_PRelu();
}

template<> inline const wnn::ELU *Op::param_as<wnn::ELU>() const {
  return param_as_ELU();
}

template<> inline const wnn::LRN *Op::param_as<wnn::LRN>() const {
  return param_as_LRN();
}

template<> inline const wnn::Softmax *Op::param_as<wnn::Softmax>() const {
  return param_as_Softmax();
}

template<> inline const wnn::Input *Op::param_as<wnn::Input>() const {
  return param_as_Input();
}

template<> inline const wnn::Extra *Op::param_as<wnn::Extra>() const {
  return param_as_Extra();
}

template<> inline const wnn::FC *Op::param_as<wnn::FC>() const {
  return param_as_FC();
}

template<> inline const wnn::ArgMax *Op::param_as<wnn::ArgMax>() const {
  return param_as_ArgMax();
}

template<> inline const wnn::Binary *Op::param_as<wnn::Binary>() const {
  return param_as_Binary();
}

template<> inline const wnn::Unary *Op::param_as<wnn::Unary>() const {
  return param_as_Unary();
}

template<> inline const wnn::Eltwise *Op::param_as<wnn::Eltwise>() const {
  return param_as_Eltwise();
}

template<> inline const wnn::Reduction *Op::param_as<wnn::Reduction>() const {
  return param_as_Reduction();
}

template<> inline const wnn::Squeeze *Op::param_as<wnn::Squeeze>() const {
  return param_as_Squeeze();
}

template<> inline const wnn::Gather *Op::param_as<wnn::Gather>() const {
  return param_as_Gather();
}

template<> inline const wnn::ExpandDims *Op::param_as<wnn::ExpandDims>() const {
  return param_as_ExpandDims();
}

template<> inline const wnn::Normalize *Op::param_as<wnn::Normalize>() const {
  return param_as_Normalize();
}

template<> inline const wnn::Flatten *Op::param_as<wnn::Flatten>() const {
  return param_as_Flatten();
}

template<> inline const wnn::Blob *Op::param_as<wnn::Blob>() const {
  return param_as_Blob();
}

template<> inline const wnn::Permute *Op::param_as<wnn::Permute>() const {
  return param_as_Permute();
}

template<> inline const wnn::Reshape *Op::param_as<wnn::Reshape>() const {
  return param_as_Reshape();
}

template<> inline const wnn::Split *Op::param_as<wnn::Split>() const {
  return param_as_Split();
}

template<> inline const wnn::ChannelShuffle *Op::param_as<wnn::ChannelShuffle>() const {
  return param_as_ChannelShuffle();
}

template<> inline const wnn::Concat *Op::param_as<wnn::Concat>() const {
  return param_as_Concat();
}

template<> inline const wnn::Interpolate *Op::param_as<wnn::Interpolate>() const {
  return param_as_Interpolate();
}

template<> inline const wnn::Einsum *Op::param_as<wnn::Einsum>() const {
  return param_as_Einsum();
}

template<> inline const wnn::Attribute *Op::param_as<wnn::Attribute>() const {
  return param_as_Attribute();
}

template<> inline const wnn::FilmLPN *Op::param_as<wnn::FilmLPN>() const {
  return param_as_FilmLPN();
}

template<> inline const wnn::Cubic *Op::param_as<wnn::Cubic>() const {
  return param_as_Cubic();
}

template<> inline const wnn::MultiHeadAttention *Op::param_as<wnn::MultiHeadAttention>() const {
  return param_as_MultiHeadAttention();
}

template<> inline const wnn::Cast *Op::param_as<wnn::Cast>() const {
  return param_as_Cast();
}

template<> inline const wnn::Pad *Op::param_as<wnn::Pad>() const {
  return param_as_Pad();
}

template<> inline const wnn::Repeat *Op::param_as<wnn::Repeat>() const {
  return param_as_Repeat();
}

template<> inline const wnn::Slice *Op::param_as<wnn::Slice>() const {
  return param_as_Slice();
}

struct OpBuilder {
  typedef Op Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input_indexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_indexes) {
    fbb_.AddOffset(Op::VT_INPUT_INDEXES, input_indexes);
  }
  void add_output_indexes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_indexes) {
    fbb_.AddOffset(Op::VT_OUTPUT_INDEXES, output_indexes);
  }
  void add_input_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input_names) {
    fbb_.AddOffset(Op::VT_INPUT_NAMES, input_names);
  }
  void add_output_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output_names) {
    fbb_.AddOffset(Op::VT_OUTPUT_NAMES, output_names);
  }
  void add_input_shapes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Dims>>> input_shapes) {
    fbb_.AddOffset(Op::VT_INPUT_SHAPES, input_shapes);
  }
  void add_output_shapes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Dims>>> output_shapes) {
    fbb_.AddOffset(Op::VT_OUTPUT_SHAPES, output_shapes);
  }
  void add_is_static_shape(bool is_static_shape) {
    fbb_.AddElement<uint8_t>(Op::VT_IS_STATIC_SHAPE, static_cast<uint8_t>(is_static_shape), 0);
  }
  void add_param_type(wnn::OpParameter param_type) {
    fbb_.AddElement<uint8_t>(Op::VT_PARAM_TYPE, static_cast<uint8_t>(param_type), 0);
  }
  void add_param(flatbuffers::Offset<void> param) {
    fbb_.AddOffset(Op::VT_PARAM, param);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Op::VT_NAME, name);
  }
  void add_type(wnn::OpType type) {
    fbb_.AddElement<int32_t>(Op::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  explicit OpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Op> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Op>(end);
    return o;
  }
};

inline flatbuffers::Offset<Op> CreateOp(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_indexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> output_indexes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input_names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output_names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Dims>>> input_shapes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Dims>>> output_shapes = 0,
    bool is_static_shape = false,
    wnn::OpParameter param_type = wnn::OpParameter_NONE,
    flatbuffers::Offset<void> param = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    wnn::OpType type = wnn::OpType_argmax) {
  OpBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_name(name);
  builder_.add_param(param);
  builder_.add_output_shapes(output_shapes);
  builder_.add_input_shapes(input_shapes);
  builder_.add_output_names(output_names);
  builder_.add_input_names(input_names);
  builder_.add_output_indexes(output_indexes);
  builder_.add_input_indexes(input_indexes);
  builder_.add_param_type(param_type);
  builder_.add_is_static_shape(is_static_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<Op> CreateOpDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *input_indexes = nullptr,
    const std::vector<int32_t> *output_indexes = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *input_names = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *output_names = nullptr,
    const std::vector<flatbuffers::Offset<wnn::Dims>> *input_shapes = nullptr,
    const std::vector<flatbuffers::Offset<wnn::Dims>> *output_shapes = nullptr,
    bool is_static_shape = false,
    wnn::OpParameter param_type = wnn::OpParameter_NONE,
    flatbuffers::Offset<void> param = 0,
    const char *name = nullptr,
    wnn::OpType type = wnn::OpType_argmax) {
  auto input_indexes__ = input_indexes ? _fbb.CreateVector<int32_t>(*input_indexes) : 0;
  auto output_indexes__ = output_indexes ? _fbb.CreateVector<int32_t>(*output_indexes) : 0;
  auto input_names__ = input_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*input_names) : 0;
  auto output_names__ = output_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*output_names) : 0;
  auto input_shapes__ = input_shapes ? _fbb.CreateVector<flatbuffers::Offset<wnn::Dims>>(*input_shapes) : 0;
  auto output_shapes__ = output_shapes ? _fbb.CreateVector<flatbuffers::Offset<wnn::Dims>>(*output_shapes) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return wnn::CreateOp(
      _fbb,
      input_indexes__,
      output_indexes__,
      input_names__,
      output_names__,
      input_shapes__,
      output_shapes__,
      is_static_shape,
      param_type,
      param,
      name__,
      type);
}

flatbuffers::Offset<Op> CreateOp(flatbuffers::FlatBufferBuilder &_fbb, const OpT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct ExtraT : public flatbuffers::NativeTable {
  typedef Extra TableType;
  std::string type{};
  std::string engine{};
  std::vector<int8_t> info{};
  std::vector<std::unique_ptr<wnn::AttributeT>> attr{};
  ExtraT() = default;
  ExtraT(const ExtraT &o);
  ExtraT(ExtraT&&) FLATBUFFERS_NOEXCEPT = default;
  ExtraT &operator=(ExtraT o) FLATBUFFERS_NOEXCEPT;
};

struct Extra FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ExtraT NativeTableType;
  typedef ExtraBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return ExtraTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ENGINE = 6,
    VT_INFO = 8,
    VT_ATTR = 10
  };
  const flatbuffers::String *type() const {
    return GetPointer<const flatbuffers::String *>(VT_TYPE);
  }
  const flatbuffers::String *engine() const {
    return GetPointer<const flatbuffers::String *>(VT_ENGINE);
  }
  const flatbuffers::Vector<int8_t> *info() const {
    return GetPointer<const flatbuffers::Vector<int8_t> *>(VT_INFO);
  }
  const flatbuffers::Vector<flatbuffers::Offset<wnn::Attribute>> *attr() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<wnn::Attribute>> *>(VT_ATTR);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_TYPE) &&
           verifier.VerifyString(type()) &&
           VerifyOffset(verifier, VT_ENGINE) &&
           verifier.VerifyString(engine()) &&
           VerifyOffset(verifier, VT_INFO) &&
           verifier.VerifyVector(info()) &&
           VerifyOffset(verifier, VT_ATTR) &&
           verifier.VerifyVector(attr()) &&
           verifier.VerifyVectorOfTables(attr()) &&
           verifier.EndTable();
  }
  ExtraT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ExtraT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Extra> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ExtraBuilder {
  typedef Extra Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(flatbuffers::Offset<flatbuffers::String> type) {
    fbb_.AddOffset(Extra::VT_TYPE, type);
  }
  void add_engine(flatbuffers::Offset<flatbuffers::String> engine) {
    fbb_.AddOffset(Extra::VT_ENGINE, engine);
  }
  void add_info(flatbuffers::Offset<flatbuffers::Vector<int8_t>> info) {
    fbb_.AddOffset(Extra::VT_INFO, info);
  }
  void add_attr(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Attribute>>> attr) {
    fbb_.AddOffset(Extra::VT_ATTR, attr);
  }
  explicit ExtraBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Extra> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Extra>(end);
    return o;
  }
};

inline flatbuffers::Offset<Extra> CreateExtra(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> type = 0,
    flatbuffers::Offset<flatbuffers::String> engine = 0,
    flatbuffers::Offset<flatbuffers::Vector<int8_t>> info = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Attribute>>> attr = 0) {
  ExtraBuilder builder_(_fbb);
  builder_.add_attr(attr);
  builder_.add_info(info);
  builder_.add_engine(engine);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Extra> CreateExtraDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *type = nullptr,
    const char *engine = nullptr,
    const std::vector<int8_t> *info = nullptr,
    std::vector<flatbuffers::Offset<wnn::Attribute>> *attr = nullptr) {
  auto type__ = type ? _fbb.CreateString(type) : 0;
  auto engine__ = engine ? _fbb.CreateString(engine) : 0;
  auto info__ = info ? _fbb.CreateVector<int8_t>(*info) : 0;
  auto attr__ = attr ? _fbb.CreateVectorOfSortedTables<wnn::Attribute>(attr) : 0;
  return wnn::CreateExtra(
      _fbb,
      type__,
      engine__,
      info__,
      attr__);
}

flatbuffers::Offset<Extra> CreateExtra(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct SubGraphT : public flatbuffers::NativeTable {
  typedef SubGraph TableType;
  std::string name{};
  std::vector<int32_t> inputs{};
  std::vector<int32_t> outputs{};
  std::vector<std::string> tensors{};
  std::vector<std::unique_ptr<wnn::OpT>> nodes{};
  SubGraphT() = default;
  SubGraphT(const SubGraphT &o);
  SubGraphT(SubGraphT&&) FLATBUFFERS_NOEXCEPT = default;
  SubGraphT &operator=(SubGraphT o) FLATBUFFERS_NOEXCEPT;
};

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SubGraphT NativeTableType;
  typedef SubGraphBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return SubGraphTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUTS = 6,
    VT_OUTPUTS = 8,
    VT_TENSORS = 10,
    VT_NODES = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<int32_t> *inputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<int32_t> *outputs() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_OUTPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<wnn::Op>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<wnn::Op>> *>(VT_NODES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfStrings(tensors()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           verifier.EndTable();
  }
  SubGraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<SubGraph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct SubGraphBuilder {
  typedef SubGraph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs) {
    fbb_.AddOffset(SubGraph::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTS, outputs);
  }
  void add_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors) {
    fbb_.AddOffset(SubGraph::VT_TENSORS, tensors);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Op>>> nodes) {
    fbb_.AddOffset(SubGraph::VT_NODES, nodes);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> outputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Op>>> nodes = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_nodes(nodes);
  builder_.add_tensors(tensors);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<int32_t> *inputs = nullptr,
    const std::vector<int32_t> *outputs = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tensors = nullptr,
    const std::vector<flatbuffers::Offset<wnn::Op>> *nodes = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<int32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<int32_t>(*outputs) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tensors) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<wnn::Op>>(*nodes) : 0;
  return wnn::CreateSubGraph(
      _fbb,
      name__,
      inputs__,
      outputs__,
      tensors__,
      nodes__);
}

flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorQuantInfoT : public flatbuffers::NativeTable {
  typedef TensorQuantInfo TableType;
  float scale = 0.0f;
  float zero = 0.0f;
  float min = -128.0f;
  float max = 127.0f;
  wnn::DataType type = wnn::DataType_DT_INVALID;
};

struct TensorQuantInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorQuantInfoT NativeTableType;
  typedef TensorQuantInfoBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorQuantInfoTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ZERO = 6,
    VT_MIN = 8,
    VT_MAX = 10,
    VT_TYPE = 12
  };
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float zero() const {
    return GetField<float>(VT_ZERO, 0.0f);
  }
  float min() const {
    return GetField<float>(VT_MIN, -128.0f);
  }
  float max() const {
    return GetField<float>(VT_MAX, 127.0f);
  }
  wnn::DataType type() const {
    return static_cast<wnn::DataType>(GetField<int32_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_SCALE, 4) &&
           VerifyField<float>(verifier, VT_ZERO, 4) &&
           VerifyField<float>(verifier, VT_MIN, 4) &&
           VerifyField<float>(verifier, VT_MAX, 4) &&
           VerifyField<int32_t>(verifier, VT_TYPE, 4) &&
           verifier.EndTable();
  }
  TensorQuantInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorQuantInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorQuantInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorQuantInfoBuilder {
  typedef TensorQuantInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(float scale) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_SCALE, scale, 0.0f);
  }
  void add_zero(float zero) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_ZERO, zero, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_MIN, min, -128.0f);
  }
  void add_max(float max) {
    fbb_.AddElement<float>(TensorQuantInfo::VT_MAX, max, 127.0f);
  }
  void add_type(wnn::DataType type) {
    fbb_.AddElement<int32_t>(TensorQuantInfo::VT_TYPE, static_cast<int32_t>(type), 0);
  }
  explicit TensorQuantInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorQuantInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorQuantInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    float scale = 0.0f,
    float zero = 0.0f,
    float min = -128.0f,
    float max = 127.0f,
    wnn::DataType type = wnn::DataType_DT_INVALID) {
  TensorQuantInfoBuilder builder_(_fbb);
  builder_.add_type(type);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_zero(zero);
  builder_.add_scale(scale);
  return builder_.Finish();
}

flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct TensorDescribeT : public flatbuffers::NativeTable {
  typedef TensorDescribe TableType;
  std::unique_ptr<wnn::BlobT> blob{};
  int32_t index = 0;
  std::string name{};
  std::unique_ptr<wnn::TensorQuantInfoT> quant_info{};
  TensorDescribeT() = default;
  TensorDescribeT(const TensorDescribeT &o);
  TensorDescribeT(TensorDescribeT&&) FLATBUFFERS_NOEXCEPT = default;
  TensorDescribeT &operator=(TensorDescribeT o) FLATBUFFERS_NOEXCEPT;
};

struct TensorDescribe FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorDescribeT NativeTableType;
  typedef TensorDescribeBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return TensorDescribeTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOB = 4,
    VT_INDEX = 6,
    VT_NAME = 8,
    VT_QUANT_INFO = 10
  };
  const wnn::Blob *blob() const {
    return GetPointer<const wnn::Blob *>(VT_BLOB);
  }
  int32_t index() const {
    return GetField<int32_t>(VT_INDEX, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const wnn::TensorQuantInfo *quant_info() const {
    return GetPointer<const wnn::TensorQuantInfo *>(VT_QUANT_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOB) &&
           verifier.VerifyTable(blob()) &&
           VerifyField<int32_t>(verifier, VT_INDEX, 4) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_QUANT_INFO) &&
           verifier.VerifyTable(quant_info()) &&
           verifier.EndTable();
  }
  TensorDescribeT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(TensorDescribeT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<TensorDescribe> Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct TensorDescribeBuilder {
  typedef TensorDescribe Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blob(flatbuffers::Offset<wnn::Blob> blob) {
    fbb_.AddOffset(TensorDescribe::VT_BLOB, blob);
  }
  void add_index(int32_t index) {
    fbb_.AddElement<int32_t>(TensorDescribe::VT_INDEX, index, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(TensorDescribe::VT_NAME, name);
  }
  void add_quant_info(flatbuffers::Offset<wnn::TensorQuantInfo> quant_info) {
    fbb_.AddOffset(TensorDescribe::VT_QUANT_INFO, quant_info);
  }
  explicit TensorDescribeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<TensorDescribe> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorDescribe>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<wnn::Blob> blob = 0,
    int32_t index = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<wnn::TensorQuantInfo> quant_info = 0) {
  TensorDescribeBuilder builder_(_fbb);
  builder_.add_quant_info(quant_info);
  builder_.add_name(name);
  builder_.add_index(index);
  builder_.add_blob(blob);
  return builder_.Finish();
}

inline flatbuffers::Offset<TensorDescribe> CreateTensorDescribeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<wnn::Blob> blob = 0,
    int32_t index = 0,
    const char *name = nullptr,
    flatbuffers::Offset<wnn::TensorQuantInfo> quant_info = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return wnn::CreateTensorDescribe(
      _fbb,
      blob,
      index,
      name__,
      quant_info);
}

flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct GraphT : public flatbuffers::NativeTable {
  typedef Graph TableType;
  std::string desc{};
  std::string usage{};
  std::string vendor{};
  std::string version{};
  std::vector<std::unique_ptr<wnn::TensorDescribeT>> extra_tensor_describe{};
  std::vector<std::unique_ptr<wnn::OpT>> oplists{};
  std::vector<std::string> output_names{};
  std::vector<std::string> input_names{};
  wnn::ModelSource model_source = wnn::ModelSource_TORCH;
  std::vector<std::string> tensor_names{};
  std::vector<std::string> tensor_index_names{};
  int32_t tensor_number = 0;
  std::unique_ptr<wnn::SubGraphT> subgraph{};
  std::string uuid{};
  std::string password{};
  GraphT() = default;
  GraphT(const GraphT &o);
  GraphT(GraphT&&) FLATBUFFERS_NOEXCEPT = default;
  GraphT &operator=(GraphT o) FLATBUFFERS_NOEXCEPT;
};

struct Graph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef GraphT NativeTableType;
  typedef GraphBuilder Builder;
  static const flatbuffers::TypeTable *MiniReflectTypeTable() {
    return GraphTypeTable();
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DESC = 4,
    VT_USAGE = 6,
    VT_VENDOR = 8,
    VT_VERSION = 10,
    VT_EXTRA_TENSOR_DESCRIBE = 12,
    VT_OPLISTS = 14,
    VT_OUTPUT_NAMES = 16,
    VT_INPUT_NAMES = 18,
    VT_MODEL_SOURCE = 20,
    VT_TENSOR_NAMES = 22,
    VT_TENSOR_INDEX_NAMES = 24,
    VT_TENSOR_NUMBER = 26,
    VT_SUBGRAPH = 28,
    VT_UUID = 30,
    VT_PASSWORD = 32
  };
  const flatbuffers::String *desc() const {
    return GetPointer<const flatbuffers::String *>(VT_DESC);
  }
  const flatbuffers::String *usage() const {
    return GetPointer<const flatbuffers::String *>(VT_USAGE);
  }
  const flatbuffers::String *vendor() const {
    return GetPointer<const flatbuffers::String *>(VT_VENDOR);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<wnn::TensorDescribe>> *extra_tensor_describe() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<wnn::TensorDescribe>> *>(VT_EXTRA_TENSOR_DESCRIBE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<wnn::Op>> *oplists() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<wnn::Op>> *>(VT_OPLISTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *output_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUT_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *input_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUT_NAMES);
  }
  wnn::ModelSource model_source() const {
    return static_cast<wnn::ModelSource>(GetField<int8_t>(VT_MODEL_SOURCE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensor_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TENSOR_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *tensor_index_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_TENSOR_INDEX_NAMES);
  }
  int32_t tensor_number() const {
    return GetField<int32_t>(VT_TENSOR_NUMBER, 0);
  }
  const wnn::SubGraph *subgraph() const {
    return GetPointer<const wnn::SubGraph *>(VT_SUBGRAPH);
  }
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const flatbuffers::String *password() const {
    return GetPointer<const flatbuffers::String *>(VT_PASSWORD);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DESC) &&
           verifier.VerifyString(desc()) &&
           VerifyOffset(verifier, VT_USAGE) &&
           verifier.VerifyString(usage()) &&
           VerifyOffset(verifier, VT_VENDOR) &&
           verifier.VerifyString(vendor()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_EXTRA_TENSOR_DESCRIBE) &&
           verifier.VerifyVector(extra_tensor_describe()) &&
           verifier.VerifyVectorOfTables(extra_tensor_describe()) &&
           VerifyOffset(verifier, VT_OPLISTS) &&
           verifier.VerifyVector(oplists()) &&
           verifier.VerifyVectorOfTables(oplists()) &&
           VerifyOffset(verifier, VT_OUTPUT_NAMES) &&
           verifier.VerifyVector(output_names()) &&
           verifier.VerifyVectorOfStrings(output_names()) &&
           VerifyOffset(verifier, VT_INPUT_NAMES) &&
           verifier.VerifyVector(input_names()) &&
           verifier.VerifyVectorOfStrings(input_names()) &&
           VerifyField<int8_t>(verifier, VT_MODEL_SOURCE, 1) &&
           VerifyOffset(verifier, VT_TENSOR_NAMES) &&
           verifier.VerifyVector(tensor_names()) &&
           verifier.VerifyVectorOfStrings(tensor_names()) &&
           VerifyOffset(verifier, VT_TENSOR_INDEX_NAMES) &&
           verifier.VerifyVector(tensor_index_names()) &&
           verifier.VerifyVectorOfStrings(tensor_index_names()) &&
           VerifyField<int32_t>(verifier, VT_TENSOR_NUMBER, 4) &&
           VerifyOffset(verifier, VT_SUBGRAPH) &&
           verifier.VerifyTable(subgraph()) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           VerifyOffset(verifier, VT_PASSWORD) &&
           verifier.VerifyString(password()) &&
           verifier.EndTable();
  }
  GraphT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(GraphT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Graph> Pack(flatbuffers::FlatBufferBuilder &_fbb, const GraphT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct GraphBuilder {
  typedef Graph Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_desc(flatbuffers::Offset<flatbuffers::String> desc) {
    fbb_.AddOffset(Graph::VT_DESC, desc);
  }
  void add_usage(flatbuffers::Offset<flatbuffers::String> usage) {
    fbb_.AddOffset(Graph::VT_USAGE, usage);
  }
  void add_vendor(flatbuffers::Offset<flatbuffers::String> vendor) {
    fbb_.AddOffset(Graph::VT_VENDOR, vendor);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(Graph::VT_VERSION, version);
  }
  void add_extra_tensor_describe(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::TensorDescribe>>> extra_tensor_describe) {
    fbb_.AddOffset(Graph::VT_EXTRA_TENSOR_DESCRIBE, extra_tensor_describe);
  }
  void add_oplists(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Op>>> oplists) {
    fbb_.AddOffset(Graph::VT_OPLISTS, oplists);
  }
  void add_output_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output_names) {
    fbb_.AddOffset(Graph::VT_OUTPUT_NAMES, output_names);
  }
  void add_input_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input_names) {
    fbb_.AddOffset(Graph::VT_INPUT_NAMES, input_names);
  }
  void add_model_source(wnn::ModelSource model_source) {
    fbb_.AddElement<int8_t>(Graph::VT_MODEL_SOURCE, static_cast<int8_t>(model_source), 0);
  }
  void add_tensor_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensor_names) {
    fbb_.AddOffset(Graph::VT_TENSOR_NAMES, tensor_names);
  }
  void add_tensor_index_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensor_index_names) {
    fbb_.AddOffset(Graph::VT_TENSOR_INDEX_NAMES, tensor_index_names);
  }
  void add_tensor_number(int32_t tensor_number) {
    fbb_.AddElement<int32_t>(Graph::VT_TENSOR_NUMBER, tensor_number, 0);
  }
  void add_subgraph(flatbuffers::Offset<wnn::SubGraph> subgraph) {
    fbb_.AddOffset(Graph::VT_SUBGRAPH, subgraph);
  }
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Graph::VT_UUID, uuid);
  }
  void add_password(flatbuffers::Offset<flatbuffers::String> password) {
    fbb_.AddOffset(Graph::VT_PASSWORD, password);
  }
  explicit GraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline flatbuffers::Offset<Graph> CreateGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> desc = 0,
    flatbuffers::Offset<flatbuffers::String> usage = 0,
    flatbuffers::Offset<flatbuffers::String> vendor = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::TensorDescribe>>> extra_tensor_describe = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<wnn::Op>>> oplists = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output_names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input_names = 0,
    wnn::ModelSource model_source = wnn::ModelSource_TORCH,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensor_names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> tensor_index_names = 0,
    int32_t tensor_number = 0,
    flatbuffers::Offset<wnn::SubGraph> subgraph = 0,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    flatbuffers::Offset<flatbuffers::String> password = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_password(password);
  builder_.add_uuid(uuid);
  builder_.add_subgraph(subgraph);
  builder_.add_tensor_number(tensor_number);
  builder_.add_tensor_index_names(tensor_index_names);
  builder_.add_tensor_names(tensor_names);
  builder_.add_input_names(input_names);
  builder_.add_output_names(output_names);
  builder_.add_oplists(oplists);
  builder_.add_extra_tensor_describe(extra_tensor_describe);
  builder_.add_version(version);
  builder_.add_vendor(vendor);
  builder_.add_usage(usage);
  builder_.add_desc(desc);
  builder_.add_model_source(model_source);
  return builder_.Finish();
}

inline flatbuffers::Offset<Graph> CreateGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *desc = nullptr,
    const char *usage = nullptr,
    const char *vendor = nullptr,
    const char *version = nullptr,
    const std::vector<flatbuffers::Offset<wnn::TensorDescribe>> *extra_tensor_describe = nullptr,
    const std::vector<flatbuffers::Offset<wnn::Op>> *oplists = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *output_names = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *input_names = nullptr,
    wnn::ModelSource model_source = wnn::ModelSource_TORCH,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tensor_names = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *tensor_index_names = nullptr,
    int32_t tensor_number = 0,
    flatbuffers::Offset<wnn::SubGraph> subgraph = 0,
    const char *uuid = nullptr,
    const char *password = nullptr) {
  auto desc__ = desc ? _fbb.CreateString(desc) : 0;
  auto usage__ = usage ? _fbb.CreateString(usage) : 0;
  auto vendor__ = vendor ? _fbb.CreateString(vendor) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto extra_tensor_describe__ = extra_tensor_describe ? _fbb.CreateVector<flatbuffers::Offset<wnn::TensorDescribe>>(*extra_tensor_describe) : 0;
  auto oplists__ = oplists ? _fbb.CreateVector<flatbuffers::Offset<wnn::Op>>(*oplists) : 0;
  auto output_names__ = output_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*output_names) : 0;
  auto input_names__ = input_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*input_names) : 0;
  auto tensor_names__ = tensor_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tensor_names) : 0;
  auto tensor_index_names__ = tensor_index_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*tensor_index_names) : 0;
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto password__ = password ? _fbb.CreateString(password) : 0;
  return wnn::CreateGraph(
      _fbb,
      desc__,
      usage__,
      vendor__,
      version__,
      extra_tensor_describe__,
      oplists__,
      output_names__,
      input_names__,
      model_source,
      tensor_names__,
      tensor_index_names__,
      tensor_number,
      subgraph,
      uuid__,
      password__);
}

flatbuffers::Offset<Graph> CreateGraph(flatbuffers::FlatBufferBuilder &_fbb, const GraphT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline DimsT *Dims::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<DimsT>(new DimsT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Dims::UnPackTo(DimsT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = shape(); if (_e) { _o->shape.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->shape[_i] = _e->Get(_i); } } }
  { auto _e = total_size(); _o->total_size = _e; }
}

inline flatbuffers::Offset<Dims> Dims::Pack(flatbuffers::FlatBufferBuilder &_fbb, const DimsT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateDims(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Dims> CreateDims(flatbuffers::FlatBufferBuilder &_fbb, const DimsT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const DimsT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _shape = _o->shape.size() ? _fbb.CreateVector(_o->shape) : 0;
  auto _total_size = _o->total_size;
  return wnn::CreateDims(
      _fbb,
      _shape,
      _total_size);
}

inline OpT::OpT(const OpT &o)
      : input_indexes(o.input_indexes),
        output_indexes(o.output_indexes),
        input_names(o.input_names),
        output_names(o.output_names),
        is_static_shape(o.is_static_shape),
        param(o.param),
        name(o.name),
        type(o.type) {
  input_shapes.reserve(o.input_shapes.size());
  for (const auto &input_shapes_ : o.input_shapes) { input_shapes.emplace_back((input_shapes_) ? new wnn::DimsT(*input_shapes_) : nullptr); }
  output_shapes.reserve(o.output_shapes.size());
  for (const auto &output_shapes_ : o.output_shapes) { output_shapes.emplace_back((output_shapes_) ? new wnn::DimsT(*output_shapes_) : nullptr); }
}

inline OpT &OpT::operator=(OpT o) FLATBUFFERS_NOEXCEPT {
  std::swap(input_indexes, o.input_indexes);
  std::swap(output_indexes, o.output_indexes);
  std::swap(input_names, o.input_names);
  std::swap(output_names, o.output_names);
  std::swap(input_shapes, o.input_shapes);
  std::swap(output_shapes, o.output_shapes);
  std::swap(is_static_shape, o.is_static_shape);
  std::swap(param, o.param);
  std::swap(name, o.name);
  std::swap(type, o.type);
  return *this;
}

inline OpT *Op::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<OpT>(new OpT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Op::UnPackTo(OpT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = input_indexes(); if (_e) { _o->input_indexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_indexes[_i] = _e->Get(_i); } } }
  { auto _e = output_indexes(); if (_e) { _o->output_indexes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_indexes[_i] = _e->Get(_i); } } }
  { auto _e = input_names(); if (_e) { _o->input_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_names[_i] = _e->Get(_i)->str(); } } }
  { auto _e = output_names(); if (_e) { _o->output_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_names[_i] = _e->Get(_i)->str(); } } }
  { auto _e = input_shapes(); if (_e) { _o->input_shapes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->input_shapes[_i]) { _e->Get(_i)->UnPackTo(_o->input_shapes[_i].get(), _resolver); } else { _o->input_shapes[_i] = std::unique_ptr<wnn::DimsT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = output_shapes(); if (_e) { _o->output_shapes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->output_shapes[_i]) { _e->Get(_i)->UnPackTo(_o->output_shapes[_i].get(), _resolver); } else { _o->output_shapes[_i] = std::unique_ptr<wnn::DimsT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = is_static_shape(); _o->is_static_shape = _e; }
  { auto _e = param_type(); _o->param.type = _e; }
  { auto _e = param(); if (_e) _o->param.value = wnn::OpParameterUnion::UnPack(_e, param_type(), _resolver); }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<Op> Op::Pack(flatbuffers::FlatBufferBuilder &_fbb, const OpT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateOp(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Op> CreateOp(flatbuffers::FlatBufferBuilder &_fbb, const OpT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const OpT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _input_indexes = _o->input_indexes.size() ? _fbb.CreateVector(_o->input_indexes) : 0;
  auto _output_indexes = _o->output_indexes.size() ? _fbb.CreateVector(_o->output_indexes) : 0;
  auto _input_names = _o->input_names.size() ? _fbb.CreateVectorOfStrings(_o->input_names) : 0;
  auto _output_names = _o->output_names.size() ? _fbb.CreateVectorOfStrings(_o->output_names) : 0;
  auto _input_shapes = _o->input_shapes.size() ? _fbb.CreateVector<flatbuffers::Offset<wnn::Dims>> (_o->input_shapes.size(), [](size_t i, _VectorArgs *__va) { return CreateDims(*__va->__fbb, __va->__o->input_shapes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _output_shapes = _o->output_shapes.size() ? _fbb.CreateVector<flatbuffers::Offset<wnn::Dims>> (_o->output_shapes.size(), [](size_t i, _VectorArgs *__va) { return CreateDims(*__va->__fbb, __va->__o->output_shapes[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _is_static_shape = _o->is_static_shape;
  auto _param_type = _o->param.type;
  auto _param = _o->param.Pack(_fbb);
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _type = _o->type;
  return wnn::CreateOp(
      _fbb,
      _input_indexes,
      _output_indexes,
      _input_names,
      _output_names,
      _input_shapes,
      _output_shapes,
      _is_static_shape,
      _param_type,
      _param,
      _name,
      _type);
}

inline ExtraT::ExtraT(const ExtraT &o)
      : type(o.type),
        engine(o.engine),
        info(o.info) {
  attr.reserve(o.attr.size());
  for (const auto &attr_ : o.attr) { attr.emplace_back((attr_) ? new wnn::AttributeT(*attr_) : nullptr); }
}

inline ExtraT &ExtraT::operator=(ExtraT o) FLATBUFFERS_NOEXCEPT {
  std::swap(type, o.type);
  std::swap(engine, o.engine);
  std::swap(info, o.info);
  std::swap(attr, o.attr);
  return *this;
}

inline ExtraT *Extra::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ExtraT>(new ExtraT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Extra::UnPackTo(ExtraT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = type(); if (_e) _o->type = _e->str(); }
  { auto _e = engine(); if (_e) _o->engine = _e->str(); }
  { auto _e = info(); if (_e) { _o->info.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->info.begin()); } }
  { auto _e = attr(); if (_e) { _o->attr.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->attr[_i]) { _e->Get(_i)->UnPackTo(_o->attr[_i].get(), _resolver); } else { _o->attr[_i] = std::unique_ptr<wnn::AttributeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<Extra> Extra::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateExtra(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Extra> CreateExtra(flatbuffers::FlatBufferBuilder &_fbb, const ExtraT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ExtraT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _type = _o->type.empty() ? 0 : _fbb.CreateString(_o->type);
  auto _engine = _o->engine.empty() ? 0 : _fbb.CreateString(_o->engine);
  auto _info = _o->info.size() ? _fbb.CreateVector(_o->info) : 0;
  auto _attr = _o->attr.size() ? _fbb.CreateVector<flatbuffers::Offset<wnn::Attribute>> (_o->attr.size(), [](size_t i, _VectorArgs *__va) { return CreateAttribute(*__va->__fbb, __va->__o->attr[i].get(), __va->__rehasher); }, &_va ) : 0;
  return wnn::CreateExtra(
      _fbb,
      _type,
      _engine,
      _info,
      _attr);
}

inline SubGraphT::SubGraphT(const SubGraphT &o)
      : name(o.name),
        inputs(o.inputs),
        outputs(o.outputs),
        tensors(o.tensors) {
  nodes.reserve(o.nodes.size());
  for (const auto &nodes_ : o.nodes) { nodes.emplace_back((nodes_) ? new wnn::OpT(*nodes_) : nullptr); }
}

inline SubGraphT &SubGraphT::operator=(SubGraphT o) FLATBUFFERS_NOEXCEPT {
  std::swap(name, o.name);
  std::swap(inputs, o.inputs);
  std::swap(outputs, o.outputs);
  std::swap(tensors, o.tensors);
  std::swap(nodes, o.nodes);
  return *this;
}

inline SubGraphT *SubGraph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<SubGraphT>(new SubGraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void SubGraph::UnPackTo(SubGraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = inputs(); if (_e) { _o->inputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->inputs[_i] = _e->Get(_i); } } }
  { auto _e = outputs(); if (_e) { _o->outputs.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->outputs[_i] = _e->Get(_i); } } }
  { auto _e = tensors(); if (_e) { _o->tensors.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensors[_i] = _e->Get(_i)->str(); } } }
  { auto _e = nodes(); if (_e) { _o->nodes.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->nodes[_i]) { _e->Get(_i)->UnPackTo(_o->nodes[_i].get(), _resolver); } else { _o->nodes[_i] = std::unique_ptr<wnn::OpT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
}

inline flatbuffers::Offset<SubGraph> SubGraph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateSubGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<SubGraph> CreateSubGraph(flatbuffers::FlatBufferBuilder &_fbb, const SubGraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const SubGraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _inputs = _o->inputs.size() ? _fbb.CreateVector(_o->inputs) : 0;
  auto _outputs = _o->outputs.size() ? _fbb.CreateVector(_o->outputs) : 0;
  auto _tensors = _o->tensors.size() ? _fbb.CreateVectorOfStrings(_o->tensors) : 0;
  auto _nodes = _o->nodes.size() ? _fbb.CreateVector<flatbuffers::Offset<wnn::Op>> (_o->nodes.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->nodes[i].get(), __va->__rehasher); }, &_va ) : 0;
  return wnn::CreateSubGraph(
      _fbb,
      _name,
      _inputs,
      _outputs,
      _tensors,
      _nodes);
}

inline TensorQuantInfoT *TensorQuantInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorQuantInfoT>(new TensorQuantInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorQuantInfo::UnPackTo(TensorQuantInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = scale(); _o->scale = _e; }
  { auto _e = zero(); _o->zero = _e; }
  { auto _e = min(); _o->min = _e; }
  { auto _e = max(); _o->max = _e; }
  { auto _e = type(); _o->type = _e; }
}

inline flatbuffers::Offset<TensorQuantInfo> TensorQuantInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorQuantInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorQuantInfo> CreateTensorQuantInfo(flatbuffers::FlatBufferBuilder &_fbb, const TensorQuantInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorQuantInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _scale = _o->scale;
  auto _zero = _o->zero;
  auto _min = _o->min;
  auto _max = _o->max;
  auto _type = _o->type;
  return wnn::CreateTensorQuantInfo(
      _fbb,
      _scale,
      _zero,
      _min,
      _max,
      _type);
}

inline TensorDescribeT::TensorDescribeT(const TensorDescribeT &o)
      : blob((o.blob) ? new wnn::BlobT(*o.blob) : nullptr),
        index(o.index),
        name(o.name),
        quant_info((o.quant_info) ? new wnn::TensorQuantInfoT(*o.quant_info) : nullptr) {
}

inline TensorDescribeT &TensorDescribeT::operator=(TensorDescribeT o) FLATBUFFERS_NOEXCEPT {
  std::swap(blob, o.blob);
  std::swap(index, o.index);
  std::swap(name, o.name);
  std::swap(quant_info, o.quant_info);
  return *this;
}

inline TensorDescribeT *TensorDescribe::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<TensorDescribeT>(new TensorDescribeT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void TensorDescribe::UnPackTo(TensorDescribeT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = blob(); if (_e) { if(_o->blob) { _e->UnPackTo(_o->blob.get(), _resolver); } else { _o->blob = std::unique_ptr<wnn::BlobT>(_e->UnPack(_resolver)); } } }
  { auto _e = index(); _o->index = _e; }
  { auto _e = name(); if (_e) _o->name = _e->str(); }
  { auto _e = quant_info(); if (_e) { if(_o->quant_info) { _e->UnPackTo(_o->quant_info.get(), _resolver); } else { _o->quant_info = std::unique_ptr<wnn::TensorQuantInfoT>(_e->UnPack(_resolver)); } } }
}

inline flatbuffers::Offset<TensorDescribe> TensorDescribe::Pack(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateTensorDescribe(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<TensorDescribe> CreateTensorDescribe(flatbuffers::FlatBufferBuilder &_fbb, const TensorDescribeT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const TensorDescribeT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _blob = _o->blob ? CreateBlob(_fbb, _o->blob.get(), _rehasher) : 0;
  auto _index = _o->index;
  auto _name = _o->name.empty() ? 0 : _fbb.CreateString(_o->name);
  auto _quant_info = _o->quant_info ? CreateTensorQuantInfo(_fbb, _o->quant_info.get(), _rehasher) : 0;
  return wnn::CreateTensorDescribe(
      _fbb,
      _blob,
      _index,
      _name,
      _quant_info);
}

inline GraphT::GraphT(const GraphT &o)
      : desc(o.desc),
        usage(o.usage),
        vendor(o.vendor),
        version(o.version),
        output_names(o.output_names),
        input_names(o.input_names),
        model_source(o.model_source),
        tensor_names(o.tensor_names),
        tensor_index_names(o.tensor_index_names),
        tensor_number(o.tensor_number),
        subgraph((o.subgraph) ? new wnn::SubGraphT(*o.subgraph) : nullptr),
        uuid(o.uuid),
        password(o.password) {
  extra_tensor_describe.reserve(o.extra_tensor_describe.size());
  for (const auto &extra_tensor_describe_ : o.extra_tensor_describe) { extra_tensor_describe.emplace_back((extra_tensor_describe_) ? new wnn::TensorDescribeT(*extra_tensor_describe_) : nullptr); }
  oplists.reserve(o.oplists.size());
  for (const auto &oplists_ : o.oplists) { oplists.emplace_back((oplists_) ? new wnn::OpT(*oplists_) : nullptr); }
}

inline GraphT &GraphT::operator=(GraphT o) FLATBUFFERS_NOEXCEPT {
  std::swap(desc, o.desc);
  std::swap(usage, o.usage);
  std::swap(vendor, o.vendor);
  std::swap(version, o.version);
  std::swap(extra_tensor_describe, o.extra_tensor_describe);
  std::swap(oplists, o.oplists);
  std::swap(output_names, o.output_names);
  std::swap(input_names, o.input_names);
  std::swap(model_source, o.model_source);
  std::swap(tensor_names, o.tensor_names);
  std::swap(tensor_index_names, o.tensor_index_names);
  std::swap(tensor_number, o.tensor_number);
  std::swap(subgraph, o.subgraph);
  std::swap(uuid, o.uuid);
  std::swap(password, o.password);
  return *this;
}

inline GraphT *Graph::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<GraphT>(new GraphT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Graph::UnPackTo(GraphT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = desc(); if (_e) _o->desc = _e->str(); }
  { auto _e = usage(); if (_e) _o->usage = _e->str(); }
  { auto _e = vendor(); if (_e) _o->vendor = _e->str(); }
  { auto _e = version(); if (_e) _o->version = _e->str(); }
  { auto _e = extra_tensor_describe(); if (_e) { _o->extra_tensor_describe.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->extra_tensor_describe[_i]) { _e->Get(_i)->UnPackTo(_o->extra_tensor_describe[_i].get(), _resolver); } else { _o->extra_tensor_describe[_i] = std::unique_ptr<wnn::TensorDescribeT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = oplists(); if (_e) { _o->oplists.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->oplists[_i]) { _e->Get(_i)->UnPackTo(_o->oplists[_i].get(), _resolver); } else { _o->oplists[_i] = std::unique_ptr<wnn::OpT>(_e->Get(_i)->UnPack(_resolver)); }; } } }
  { auto _e = output_names(); if (_e) { _o->output_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->output_names[_i] = _e->Get(_i)->str(); } } }
  { auto _e = input_names(); if (_e) { _o->input_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->input_names[_i] = _e->Get(_i)->str(); } } }
  { auto _e = model_source(); _o->model_source = _e; }
  { auto _e = tensor_names(); if (_e) { _o->tensor_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensor_names[_i] = _e->Get(_i)->str(); } } }
  { auto _e = tensor_index_names(); if (_e) { _o->tensor_index_names.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->tensor_index_names[_i] = _e->Get(_i)->str(); } } }
  { auto _e = tensor_number(); _o->tensor_number = _e; }
  { auto _e = subgraph(); if (_e) { if(_o->subgraph) { _e->UnPackTo(_o->subgraph.get(), _resolver); } else { _o->subgraph = std::unique_ptr<wnn::SubGraphT>(_e->UnPack(_resolver)); } } }
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); }
  { auto _e = password(); if (_e) _o->password = _e->str(); }
}

inline flatbuffers::Offset<Graph> Graph::Pack(flatbuffers::FlatBufferBuilder &_fbb, const GraphT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateGraph(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Graph> CreateGraph(flatbuffers::FlatBufferBuilder &_fbb, const GraphT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const GraphT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _desc = _o->desc.empty() ? 0 : _fbb.CreateString(_o->desc);
  auto _usage = _o->usage.empty() ? 0 : _fbb.CreateString(_o->usage);
  auto _vendor = _o->vendor.empty() ? 0 : _fbb.CreateString(_o->vendor);
  auto _version = _o->version.empty() ? 0 : _fbb.CreateString(_o->version);
  auto _extra_tensor_describe = _o->extra_tensor_describe.size() ? _fbb.CreateVector<flatbuffers::Offset<wnn::TensorDescribe>> (_o->extra_tensor_describe.size(), [](size_t i, _VectorArgs *__va) { return CreateTensorDescribe(*__va->__fbb, __va->__o->extra_tensor_describe[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _oplists = _o->oplists.size() ? _fbb.CreateVector<flatbuffers::Offset<wnn::Op>> (_o->oplists.size(), [](size_t i, _VectorArgs *__va) { return CreateOp(*__va->__fbb, __va->__o->oplists[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _output_names = _o->output_names.size() ? _fbb.CreateVectorOfStrings(_o->output_names) : 0;
  auto _input_names = _o->input_names.size() ? _fbb.CreateVectorOfStrings(_o->input_names) : 0;
  auto _model_source = _o->model_source;
  auto _tensor_names = _o->tensor_names.size() ? _fbb.CreateVectorOfStrings(_o->tensor_names) : 0;
  auto _tensor_index_names = _o->tensor_index_names.size() ? _fbb.CreateVectorOfStrings(_o->tensor_index_names) : 0;
  auto _tensor_number = _o->tensor_number;
  auto _subgraph = _o->subgraph ? CreateSubGraph(_fbb, _o->subgraph.get(), _rehasher) : 0;
  auto _uuid = _o->uuid.empty() ? 0 : _fbb.CreateString(_o->uuid);
  auto _password = _o->password.empty() ? 0 : _fbb.CreateString(_o->password);
  return wnn::CreateGraph(
      _fbb,
      _desc,
      _usage,
      _vendor,
      _version,
      _extra_tensor_describe,
      _oplists,
      _output_names,
      _input_names,
      _model_source,
      _tensor_names,
      _tensor_index_names,
      _tensor_number,
      _subgraph,
      _uuid,
      _password);
}

inline bool VerifyOpParameter(flatbuffers::Verifier &verifier, const void *obj, OpParameter type) {
  switch (type) {
    case OpParameter_NONE: {
      return true;
    }
    case OpParameter_Conv2DCommon: {
      auto ptr = reinterpret_cast<const wnn::Conv2DCommon *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Conv2D: {
      auto ptr = reinterpret_cast<const wnn::Conv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const wnn::Pool *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_AdaptiveAvgPool2D: {
      auto ptr = reinterpret_cast<const wnn::AdaptiveAvgPool2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const wnn::LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const wnn::BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const wnn::Relu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const wnn::Relu6 *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const wnn::PRelu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const wnn::ELU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const wnn::LRN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Softmax: {
      auto ptr = reinterpret_cast<const wnn::Softmax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const wnn::Input *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const wnn::Extra *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_FC: {
      auto ptr = reinterpret_cast<const wnn::FC *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const wnn::ArgMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Binary: {
      auto ptr = reinterpret_cast<const wnn::Binary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Unary: {
      auto ptr = reinterpret_cast<const wnn::Unary *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const wnn::Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Reduction: {
      auto ptr = reinterpret_cast<const wnn::Reduction *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Squeeze: {
      auto ptr = reinterpret_cast<const wnn::Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const wnn::Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const wnn::ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const wnn::Normalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const wnn::Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const wnn::Blob *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const wnn::Permute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const wnn::Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Split: {
      auto ptr = reinterpret_cast<const wnn::Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_ChannelShuffle: {
      auto ptr = reinterpret_cast<const wnn::ChannelShuffle *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Concat: {
      auto ptr = reinterpret_cast<const wnn::Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Interpolate: {
      auto ptr = reinterpret_cast<const wnn::Interpolate *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Einsum: {
      auto ptr = reinterpret_cast<const wnn::Einsum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Attribute: {
      auto ptr = reinterpret_cast<const wnn::Attribute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_FilmLPN: {
      auto ptr = reinterpret_cast<const wnn::FilmLPN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Cubic: {
      auto ptr = reinterpret_cast<const wnn::Cubic *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_MultiHeadAttention: {
      auto ptr = reinterpret_cast<const wnn::MultiHeadAttention *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Cast: {
      auto ptr = reinterpret_cast<const wnn::Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Pad: {
      auto ptr = reinterpret_cast<const wnn::Pad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Repeat: {
      auto ptr = reinterpret_cast<const wnn::Repeat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const wnn::Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyOpParameterVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyOpParameter(
        verifier,  values->Get(i), types->GetEnum<OpParameter>(i))) {
      return false;
    }
  }
  return true;
}

inline void *OpParameterUnion::UnPack(const void *obj, OpParameter type, const flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case OpParameter_Conv2DCommon: {
      auto ptr = reinterpret_cast<const wnn::Conv2DCommon *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Conv2D: {
      auto ptr = reinterpret_cast<const wnn::Conv2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const wnn::Pool *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_AdaptiveAvgPool2D: {
      auto ptr = reinterpret_cast<const wnn::AdaptiveAvgPool2D *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const wnn::LayerNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const wnn::BatchNorm *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const wnn::Relu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const wnn::Relu6 *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const wnn::PRelu *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const wnn::ELU *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const wnn::LRN *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Softmax: {
      auto ptr = reinterpret_cast<const wnn::Softmax *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const wnn::Input *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const wnn::Extra *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_FC: {
      auto ptr = reinterpret_cast<const wnn::FC *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const wnn::ArgMax *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Binary: {
      auto ptr = reinterpret_cast<const wnn::Binary *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Unary: {
      auto ptr = reinterpret_cast<const wnn::Unary *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const wnn::Eltwise *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Reduction: {
      auto ptr = reinterpret_cast<const wnn::Reduction *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Squeeze: {
      auto ptr = reinterpret_cast<const wnn::Squeeze *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const wnn::Gather *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const wnn::ExpandDims *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const wnn::Normalize *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const wnn::Flatten *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const wnn::Blob *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const wnn::Permute *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const wnn::Reshape *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Split: {
      auto ptr = reinterpret_cast<const wnn::Split *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_ChannelShuffle: {
      auto ptr = reinterpret_cast<const wnn::ChannelShuffle *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Concat: {
      auto ptr = reinterpret_cast<const wnn::Concat *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Interpolate: {
      auto ptr = reinterpret_cast<const wnn::Interpolate *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Einsum: {
      auto ptr = reinterpret_cast<const wnn::Einsum *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Attribute: {
      auto ptr = reinterpret_cast<const wnn::Attribute *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_FilmLPN: {
      auto ptr = reinterpret_cast<const wnn::FilmLPN *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Cubic: {
      auto ptr = reinterpret_cast<const wnn::Cubic *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_MultiHeadAttention: {
      auto ptr = reinterpret_cast<const wnn::MultiHeadAttention *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Cast: {
      auto ptr = reinterpret_cast<const wnn::Cast *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Pad: {
      auto ptr = reinterpret_cast<const wnn::Pad *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Repeat: {
      auto ptr = reinterpret_cast<const wnn::Repeat *>(obj);
      return ptr->UnPack(resolver);
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const wnn::Slice *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline flatbuffers::Offset<void> OpParameterUnion::Pack(flatbuffers::FlatBufferBuilder &_fbb, const flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case OpParameter_Conv2DCommon: {
      auto ptr = reinterpret_cast<const wnn::Conv2DCommonT *>(value);
      return CreateConv2DCommon(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Conv2D: {
      auto ptr = reinterpret_cast<const wnn::Conv2DT *>(value);
      return CreateConv2D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<const wnn::PoolT *>(value);
      return CreatePool(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_AdaptiveAvgPool2D: {
      auto ptr = reinterpret_cast<const wnn::AdaptiveAvgPool2DT *>(value);
      return CreateAdaptiveAvgPool2D(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<const wnn::LayerNormT *>(value);
      return CreateLayerNorm(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<const wnn::BatchNormT *>(value);
      return CreateBatchNorm(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<const wnn::ReluT *>(value);
      return CreateRelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<const wnn::Relu6T *>(value);
      return CreateRelu6(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<const wnn::PReluT *>(value);
      return CreatePRelu(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<const wnn::ELUT *>(value);
      return CreateELU(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<const wnn::LRNT *>(value);
      return CreateLRN(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Softmax: {
      auto ptr = reinterpret_cast<const wnn::SoftmaxT *>(value);
      return CreateSoftmax(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<const wnn::InputT *>(value);
      return CreateInput(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<const wnn::ExtraT *>(value);
      return CreateExtra(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_FC: {
      auto ptr = reinterpret_cast<const wnn::FCT *>(value);
      return CreateFC(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<const wnn::ArgMaxT *>(value);
      return CreateArgMax(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Binary: {
      auto ptr = reinterpret_cast<const wnn::BinaryT *>(value);
      return CreateBinary(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Unary: {
      auto ptr = reinterpret_cast<const wnn::UnaryT *>(value);
      return CreateUnary(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<const wnn::EltwiseT *>(value);
      return CreateEltwise(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Reduction: {
      auto ptr = reinterpret_cast<const wnn::ReductionT *>(value);
      return CreateReduction(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Squeeze: {
      auto ptr = reinterpret_cast<const wnn::SqueezeT *>(value);
      return CreateSqueeze(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<const wnn::GatherT *>(value);
      return CreateGather(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<const wnn::ExpandDimsT *>(value);
      return CreateExpandDims(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<const wnn::NormalizeT *>(value);
      return CreateNormalize(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<const wnn::FlattenT *>(value);
      return CreateFlatten(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<const wnn::BlobT *>(value);
      return CreateBlob(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<const wnn::PermuteT *>(value);
      return CreatePermute(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<const wnn::ReshapeT *>(value);
      return CreateReshape(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Split: {
      auto ptr = reinterpret_cast<const wnn::SplitT *>(value);
      return CreateSplit(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_ChannelShuffle: {
      auto ptr = reinterpret_cast<const wnn::ChannelShuffleT *>(value);
      return CreateChannelShuffle(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Concat: {
      auto ptr = reinterpret_cast<const wnn::ConcatT *>(value);
      return CreateConcat(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Interpolate: {
      auto ptr = reinterpret_cast<const wnn::InterpolateT *>(value);
      return CreateInterpolate(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Einsum: {
      auto ptr = reinterpret_cast<const wnn::EinsumT *>(value);
      return CreateEinsum(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Attribute: {
      auto ptr = reinterpret_cast<const wnn::AttributeT *>(value);
      return CreateAttribute(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_FilmLPN: {
      auto ptr = reinterpret_cast<const wnn::FilmLPNT *>(value);
      return CreateFilmLPN(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Cubic: {
      auto ptr = reinterpret_cast<const wnn::CubicT *>(value);
      return CreateCubic(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_MultiHeadAttention: {
      auto ptr = reinterpret_cast<const wnn::MultiHeadAttentionT *>(value);
      return CreateMultiHeadAttention(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Cast: {
      auto ptr = reinterpret_cast<const wnn::CastT *>(value);
      return CreateCast(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Pad: {
      auto ptr = reinterpret_cast<const wnn::PadT *>(value);
      return CreatePad(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Repeat: {
      auto ptr = reinterpret_cast<const wnn::RepeatT *>(value);
      return CreateRepeat(_fbb, ptr, _rehasher).Union();
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<const wnn::SliceT *>(value);
      return CreateSlice(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline OpParameterUnion::OpParameterUnion(const OpParameterUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case OpParameter_Conv2DCommon: {
      value = new wnn::Conv2DCommonT(*reinterpret_cast<wnn::Conv2DCommonT *>(u.value));
      break;
    }
    case OpParameter_Conv2D: {
      value = new wnn::Conv2DT(*reinterpret_cast<wnn::Conv2DT *>(u.value));
      break;
    }
    case OpParameter_Pool: {
      value = new wnn::PoolT(*reinterpret_cast<wnn::PoolT *>(u.value));
      break;
    }
    case OpParameter_AdaptiveAvgPool2D: {
      value = new wnn::AdaptiveAvgPool2DT(*reinterpret_cast<wnn::AdaptiveAvgPool2DT *>(u.value));
      break;
    }
    case OpParameter_LayerNorm: {
      value = new wnn::LayerNormT(*reinterpret_cast<wnn::LayerNormT *>(u.value));
      break;
    }
    case OpParameter_BatchNorm: {
      value = new wnn::BatchNormT(*reinterpret_cast<wnn::BatchNormT *>(u.value));
      break;
    }
    case OpParameter_Relu: {
      value = new wnn::ReluT(*reinterpret_cast<wnn::ReluT *>(u.value));
      break;
    }
    case OpParameter_Relu6: {
      value = new wnn::Relu6T(*reinterpret_cast<wnn::Relu6T *>(u.value));
      break;
    }
    case OpParameter_PRelu: {
      value = new wnn::PReluT(*reinterpret_cast<wnn::PReluT *>(u.value));
      break;
    }
    case OpParameter_ELU: {
      value = new wnn::ELUT(*reinterpret_cast<wnn::ELUT *>(u.value));
      break;
    }
    case OpParameter_LRN: {
      value = new wnn::LRNT(*reinterpret_cast<wnn::LRNT *>(u.value));
      break;
    }
    case OpParameter_Softmax: {
      value = new wnn::SoftmaxT(*reinterpret_cast<wnn::SoftmaxT *>(u.value));
      break;
    }
    case OpParameter_Input: {
      value = new wnn::InputT(*reinterpret_cast<wnn::InputT *>(u.value));
      break;
    }
    case OpParameter_Extra: {
      value = new wnn::ExtraT(*reinterpret_cast<wnn::ExtraT *>(u.value));
      break;
    }
    case OpParameter_FC: {
      value = new wnn::FCT(*reinterpret_cast<wnn::FCT *>(u.value));
      break;
    }
    case OpParameter_ArgMax: {
      value = new wnn::ArgMaxT(*reinterpret_cast<wnn::ArgMaxT *>(u.value));
      break;
    }
    case OpParameter_Binary: {
      value = new wnn::BinaryT(*reinterpret_cast<wnn::BinaryT *>(u.value));
      break;
    }
    case OpParameter_Unary: {
      value = new wnn::UnaryT(*reinterpret_cast<wnn::UnaryT *>(u.value));
      break;
    }
    case OpParameter_Eltwise: {
      value = new wnn::EltwiseT(*reinterpret_cast<wnn::EltwiseT *>(u.value));
      break;
    }
    case OpParameter_Reduction: {
      value = new wnn::ReductionT(*reinterpret_cast<wnn::ReductionT *>(u.value));
      break;
    }
    case OpParameter_Squeeze: {
      value = new wnn::SqueezeT(*reinterpret_cast<wnn::SqueezeT *>(u.value));
      break;
    }
    case OpParameter_Gather: {
      value = new wnn::GatherT(*reinterpret_cast<wnn::GatherT *>(u.value));
      break;
    }
    case OpParameter_ExpandDims: {
      value = new wnn::ExpandDimsT(*reinterpret_cast<wnn::ExpandDimsT *>(u.value));
      break;
    }
    case OpParameter_Normalize: {
      value = new wnn::NormalizeT(*reinterpret_cast<wnn::NormalizeT *>(u.value));
      break;
    }
    case OpParameter_Flatten: {
      value = new wnn::FlattenT(*reinterpret_cast<wnn::FlattenT *>(u.value));
      break;
    }
    case OpParameter_Blob: {
      value = new wnn::BlobT(*reinterpret_cast<wnn::BlobT *>(u.value));
      break;
    }
    case OpParameter_Permute: {
      value = new wnn::PermuteT(*reinterpret_cast<wnn::PermuteT *>(u.value));
      break;
    }
    case OpParameter_Reshape: {
      value = new wnn::ReshapeT(*reinterpret_cast<wnn::ReshapeT *>(u.value));
      break;
    }
    case OpParameter_Split: {
      value = new wnn::SplitT(*reinterpret_cast<wnn::SplitT *>(u.value));
      break;
    }
    case OpParameter_ChannelShuffle: {
      value = new wnn::ChannelShuffleT(*reinterpret_cast<wnn::ChannelShuffleT *>(u.value));
      break;
    }
    case OpParameter_Concat: {
      value = new wnn::ConcatT(*reinterpret_cast<wnn::ConcatT *>(u.value));
      break;
    }
    case OpParameter_Interpolate: {
      value = new wnn::InterpolateT(*reinterpret_cast<wnn::InterpolateT *>(u.value));
      break;
    }
    case OpParameter_Einsum: {
      value = new wnn::EinsumT(*reinterpret_cast<wnn::EinsumT *>(u.value));
      break;
    }
    case OpParameter_Attribute: {
      value = new wnn::AttributeT(*reinterpret_cast<wnn::AttributeT *>(u.value));
      break;
    }
    case OpParameter_FilmLPN: {
      value = new wnn::FilmLPNT(*reinterpret_cast<wnn::FilmLPNT *>(u.value));
      break;
    }
    case OpParameter_Cubic: {
      value = new wnn::CubicT(*reinterpret_cast<wnn::CubicT *>(u.value));
      break;
    }
    case OpParameter_MultiHeadAttention: {
      value = new wnn::MultiHeadAttentionT(*reinterpret_cast<wnn::MultiHeadAttentionT *>(u.value));
      break;
    }
    case OpParameter_Cast: {
      value = new wnn::CastT(*reinterpret_cast<wnn::CastT *>(u.value));
      break;
    }
    case OpParameter_Pad: {
      value = new wnn::PadT(*reinterpret_cast<wnn::PadT *>(u.value));
      break;
    }
    case OpParameter_Repeat: {
      value = new wnn::RepeatT(*reinterpret_cast<wnn::RepeatT *>(u.value));
      break;
    }
    case OpParameter_Slice: {
      value = new wnn::SliceT(*reinterpret_cast<wnn::SliceT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void OpParameterUnion::Reset() {
  switch (type) {
    case OpParameter_Conv2DCommon: {
      auto ptr = reinterpret_cast<wnn::Conv2DCommonT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Conv2D: {
      auto ptr = reinterpret_cast<wnn::Conv2DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Pool: {
      auto ptr = reinterpret_cast<wnn::PoolT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_AdaptiveAvgPool2D: {
      auto ptr = reinterpret_cast<wnn::AdaptiveAvgPool2DT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LayerNorm: {
      auto ptr = reinterpret_cast<wnn::LayerNormT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_BatchNorm: {
      auto ptr = reinterpret_cast<wnn::BatchNormT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Relu: {
      auto ptr = reinterpret_cast<wnn::ReluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Relu6: {
      auto ptr = reinterpret_cast<wnn::Relu6T *>(value);
      delete ptr;
      break;
    }
    case OpParameter_PRelu: {
      auto ptr = reinterpret_cast<wnn::PReluT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ELU: {
      auto ptr = reinterpret_cast<wnn::ELUT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_LRN: {
      auto ptr = reinterpret_cast<wnn::LRNT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Softmax: {
      auto ptr = reinterpret_cast<wnn::SoftmaxT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Input: {
      auto ptr = reinterpret_cast<wnn::InputT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Extra: {
      auto ptr = reinterpret_cast<wnn::ExtraT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_FC: {
      auto ptr = reinterpret_cast<wnn::FCT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ArgMax: {
      auto ptr = reinterpret_cast<wnn::ArgMaxT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Binary: {
      auto ptr = reinterpret_cast<wnn::BinaryT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Unary: {
      auto ptr = reinterpret_cast<wnn::UnaryT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Eltwise: {
      auto ptr = reinterpret_cast<wnn::EltwiseT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Reduction: {
      auto ptr = reinterpret_cast<wnn::ReductionT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Squeeze: {
      auto ptr = reinterpret_cast<wnn::SqueezeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Gather: {
      auto ptr = reinterpret_cast<wnn::GatherT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ExpandDims: {
      auto ptr = reinterpret_cast<wnn::ExpandDimsT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Normalize: {
      auto ptr = reinterpret_cast<wnn::NormalizeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Flatten: {
      auto ptr = reinterpret_cast<wnn::FlattenT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Blob: {
      auto ptr = reinterpret_cast<wnn::BlobT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Permute: {
      auto ptr = reinterpret_cast<wnn::PermuteT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Reshape: {
      auto ptr = reinterpret_cast<wnn::ReshapeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Split: {
      auto ptr = reinterpret_cast<wnn::SplitT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_ChannelShuffle: {
      auto ptr = reinterpret_cast<wnn::ChannelShuffleT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Concat: {
      auto ptr = reinterpret_cast<wnn::ConcatT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Interpolate: {
      auto ptr = reinterpret_cast<wnn::InterpolateT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Einsum: {
      auto ptr = reinterpret_cast<wnn::EinsumT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Attribute: {
      auto ptr = reinterpret_cast<wnn::AttributeT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_FilmLPN: {
      auto ptr = reinterpret_cast<wnn::FilmLPNT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Cubic: {
      auto ptr = reinterpret_cast<wnn::CubicT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_MultiHeadAttention: {
      auto ptr = reinterpret_cast<wnn::MultiHeadAttentionT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Cast: {
      auto ptr = reinterpret_cast<wnn::CastT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Pad: {
      auto ptr = reinterpret_cast<wnn::PadT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Repeat: {
      auto ptr = reinterpret_cast<wnn::RepeatT *>(value);
      delete ptr;
      break;
    }
    case OpParameter_Slice: {
      auto ptr = reinterpret_cast<wnn::SliceT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = OpParameter_NONE;
}

inline const flatbuffers::TypeTable *ModelSourceTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 },
    { flatbuffers::ET_CHAR, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::ModelSourceTypeTable
  };
  static const char * const names[] = {
    "TORCH",
    "TENSORFLOW",
    "ONNX",
    "TFLITE"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_ENUM, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpParameterTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 2 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_SEQUENCE, 0, 4 },
    { flatbuffers::ET_SEQUENCE, 0, 5 },
    { flatbuffers::ET_SEQUENCE, 0, 6 },
    { flatbuffers::ET_SEQUENCE, 0, 7 },
    { flatbuffers::ET_SEQUENCE, 0, 8 },
    { flatbuffers::ET_SEQUENCE, 0, 9 },
    { flatbuffers::ET_SEQUENCE, 0, 10 },
    { flatbuffers::ET_SEQUENCE, 0, 11 },
    { flatbuffers::ET_SEQUENCE, 0, 12 },
    { flatbuffers::ET_SEQUENCE, 0, 13 },
    { flatbuffers::ET_SEQUENCE, 0, 14 },
    { flatbuffers::ET_SEQUENCE, 0, 15 },
    { flatbuffers::ET_SEQUENCE, 0, 16 },
    { flatbuffers::ET_SEQUENCE, 0, 17 },
    { flatbuffers::ET_SEQUENCE, 0, 18 },
    { flatbuffers::ET_SEQUENCE, 0, 19 },
    { flatbuffers::ET_SEQUENCE, 0, 20 },
    { flatbuffers::ET_SEQUENCE, 0, 21 },
    { flatbuffers::ET_SEQUENCE, 0, 22 },
    { flatbuffers::ET_SEQUENCE, 0, 23 },
    { flatbuffers::ET_SEQUENCE, 0, 24 },
    { flatbuffers::ET_SEQUENCE, 0, 25 },
    { flatbuffers::ET_SEQUENCE, 0, 26 },
    { flatbuffers::ET_SEQUENCE, 0, 27 },
    { flatbuffers::ET_SEQUENCE, 0, 28 },
    { flatbuffers::ET_SEQUENCE, 0, 29 },
    { flatbuffers::ET_SEQUENCE, 0, 30 },
    { flatbuffers::ET_SEQUENCE, 0, 31 },
    { flatbuffers::ET_SEQUENCE, 0, 32 },
    { flatbuffers::ET_SEQUENCE, 0, 33 },
    { flatbuffers::ET_SEQUENCE, 0, 34 },
    { flatbuffers::ET_SEQUENCE, 0, 35 },
    { flatbuffers::ET_SEQUENCE, 0, 36 },
    { flatbuffers::ET_SEQUENCE, 0, 37 },
    { flatbuffers::ET_SEQUENCE, 0, 38 },
    { flatbuffers::ET_SEQUENCE, 0, 39 },
    { flatbuffers::ET_SEQUENCE, 0, 40 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::Conv2DCommonTypeTable,
    wnn::Conv2DTypeTable,
    wnn::PoolTypeTable,
    wnn::AdaptiveAvgPool2DTypeTable,
    wnn::LayerNormTypeTable,
    wnn::BatchNormTypeTable,
    wnn::ReluTypeTable,
    wnn::Relu6TypeTable,
    wnn::PReluTypeTable,
    wnn::ELUTypeTable,
    wnn::LRNTypeTable,
    wnn::SoftmaxTypeTable,
    wnn::InputTypeTable,
    wnn::ExtraTypeTable,
    wnn::FCTypeTable,
    wnn::ArgMaxTypeTable,
    wnn::BinaryTypeTable,
    wnn::UnaryTypeTable,
    wnn::EltwiseTypeTable,
    wnn::ReductionTypeTable,
    wnn::SqueezeTypeTable,
    wnn::GatherTypeTable,
    wnn::ExpandDimsTypeTable,
    wnn::NormalizeTypeTable,
    wnn::FlattenTypeTable,
    wnn::BlobTypeTable,
    wnn::PermuteTypeTable,
    wnn::ReshapeTypeTable,
    wnn::SplitTypeTable,
    wnn::ChannelShuffleTypeTable,
    wnn::ConcatTypeTable,
    wnn::InterpolateTypeTable,
    wnn::EinsumTypeTable,
    wnn::AttributeTypeTable,
    wnn::FilmLPNTypeTable,
    wnn::CubicTypeTable,
    wnn::MultiHeadAttentionTypeTable,
    wnn::CastTypeTable,
    wnn::PadTypeTable,
    wnn::RepeatTypeTable,
    wnn::SliceTypeTable
  };
  static const char * const names[] = {
    "NONE",
    "Conv2DCommon",
    "Conv2D",
    "Pool",
    "AdaptiveAvgPool2D",
    "LayerNorm",
    "BatchNorm",
    "Relu",
    "Relu6",
    "PRelu",
    "ELU",
    "LRN",
    "Softmax",
    "Input",
    "Extra",
    "FC",
    "ArgMax",
    "Binary",
    "Unary",
    "Eltwise",
    "Reduction",
    "Squeeze",
    "Gather",
    "ExpandDims",
    "Normalize",
    "Flatten",
    "Blob",
    "Permute",
    "Reshape",
    "Split",
    "ChannelShuffle",
    "Concat",
    "Interpolate",
    "Einsum",
    "Attribute",
    "FilmLPN",
    "Cubic",
    "MultiHeadAttention",
    "Cast",
    "Pad",
    "Repeat",
    "Slice"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_UNION, 42, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *DimsTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 }
  };
  static const char * const names[] = {
    "shape",
    "total_size"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 2, type_codes, nullptr, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *OpTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_BOOL, 0, -1 },
    { flatbuffers::ET_UTYPE, 0, 1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 0, 2 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::DimsTypeTable,
    wnn::OpParameterTypeTable,
    wnn::OpTypeTypeTable
  };
  static const char * const names[] = {
    "input_indexes",
    "output_indexes",
    "input_names",
    "output_names",
    "input_shapes",
    "output_shapes",
    "is_static_shape",
    "param_type",
    "param",
    "name",
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 11, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *ExtraTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_CHAR, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::AttributeTypeTable
  };
  static const char * const names[] = {
    "type",
    "engine",
    "info",
    "attr"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *SubGraphTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_INT, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::OpTypeTable
  };
  static const char * const names[] = {
    "name",
    "inputs",
    "outputs",
    "tensors",
    "nodes"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorQuantInfoTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_FLOAT, 0, -1 },
    { flatbuffers::ET_INT, 0, 0 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::DataTypeTypeTable
  };
  static const char * const names[] = {
    "scale",
    "zero",
    "min",
    "max",
    "type"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 5, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *TensorDescribeTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_SEQUENCE, 0, 0 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::BlobTypeTable,
    wnn::TensorQuantInfoTypeTable
  };
  static const char * const names[] = {
    "blob",
    "index",
    "name",
    "quant_info"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 4, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const flatbuffers::TypeTable *GraphTypeTable() {
  static const flatbuffers::TypeCode type_codes[] = {
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 1, 0 },
    { flatbuffers::ET_SEQUENCE, 1, 1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_CHAR, 0, 2 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_STRING, 1, -1 },
    { flatbuffers::ET_INT, 0, -1 },
    { flatbuffers::ET_SEQUENCE, 0, 3 },
    { flatbuffers::ET_STRING, 0, -1 },
    { flatbuffers::ET_STRING, 0, -1 }
  };
  static const flatbuffers::TypeFunction type_refs[] = {
    wnn::TensorDescribeTypeTable,
    wnn::OpTypeTable,
    wnn::ModelSourceTypeTable,
    wnn::SubGraphTypeTable
  };
  static const char * const names[] = {
    "desc",
    "usage",
    "vendor",
    "version",
    "extra_tensor_describe",
    "oplists",
    "output_names",
    "input_names",
    "model_source",
    "tensor_names",
    "tensor_index_names",
    "tensor_number",
    "subgraph",
    "uuid",
    "password"
  };
  static const flatbuffers::TypeTable tt = {
    flatbuffers::ST_TABLE, 15, type_codes, type_refs, nullptr, nullptr, names
  };
  return &tt;
}

inline const wnn::Graph *GetGraph(const void *buf) {
  return flatbuffers::GetRoot<wnn::Graph>(buf);
}

inline const wnn::Graph *GetSizePrefixedGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<wnn::Graph>(buf);
}

inline bool VerifyGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<wnn::Graph>(nullptr);
}

inline bool VerifySizePrefixedGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<wnn::Graph>(nullptr);
}

inline void FinishGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<wnn::Graph> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<wnn::Graph> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<wnn::GraphT> UnPackGraph(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<wnn::GraphT>(GetGraph(buf)->UnPack(res));
}

inline std::unique_ptr<wnn::GraphT> UnPackSizePrefixedGraph(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<wnn::GraphT>(GetSizePrefixedGraph(buf)->UnPack(res));
}

}  // namespace wnn

#endif  // FLATBUFFERS_GENERATED_WNNX_WNN_H_
